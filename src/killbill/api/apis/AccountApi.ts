/* tslint:disable */
/* eslint-disable */
/**
 * Kill Bill
 * Kill Bill is an open-source billing and payments platform
 *
 * The version of the OpenAPI document: 0.24.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as runtime from '../runtime';
import type {
	Account,
	AccountEmail,
	AccountTimeline,
	AuditLog,
	BlockingState,
	Bundle,
	CustomField,
	Invoice,
	InvoicePayment,
	OverdueState,
	Payment,
	PaymentMethod,
	PaymentTransaction,
	Tag
} from '../models';
import {
	AccountFromJSON,
	AccountToJSON,
	AccountEmailFromJSON,
	AccountEmailToJSON,
	AccountTimelineFromJSON,
	AccountTimelineToJSON,
	AuditLogFromJSON,
	AuditLogToJSON,
	BlockingStateFromJSON,
	BlockingStateToJSON,
	BundleFromJSON,
	BundleToJSON,
	CustomFieldFromJSON,
	CustomFieldToJSON,
	InvoiceFromJSON,
	InvoiceToJSON,
	InvoicePaymentFromJSON,
	InvoicePaymentToJSON,
	OverdueStateFromJSON,
	OverdueStateToJSON,
	PaymentFromJSON,
	PaymentToJSON,
	PaymentMethodFromJSON,
	PaymentMethodToJSON,
	PaymentTransactionFromJSON,
	PaymentTransactionToJSON,
	TagFromJSON,
	TagToJSON
} from '../models';

export interface AddAccountBlockingStateRequest {
	body: BlockingState;
	accountId: string;
	xKillbillCreatedBy: string;
	requestedDate?: Date;
	pluginProperty?: Array<string>;
	xKillbillReason?: string;
	xKillbillComment?: string;
}

export interface AddEmailRequest {
	body: AccountEmail;
	accountId: string;
	xKillbillCreatedBy: string;
	xKillbillReason?: string;
	xKillbillComment?: string;
}

export interface CloseAccountRequest {
	accountId: string;
	xKillbillCreatedBy: string;
	cancelAllSubscriptions?: boolean;
	writeOffUnpaidInvoices?: boolean;
	itemAdjustUnpaidInvoices?: boolean;
	removeFutureNotifications?: boolean;
	xKillbillReason?: string;
	xKillbillComment?: string;
}

export interface CreateAccountRequest {
	body: Account;
	xKillbillCreatedBy: string;
	xKillbillReason?: string;
	xKillbillComment?: string;
}

export interface CreateAccountCustomFieldsRequest {
	body: Array<CustomField>;
	accountId: string;
	xKillbillCreatedBy: string;
	xKillbillReason?: string;
	xKillbillComment?: string;
}

export interface CreateAccountTagsRequest {
	body: Array<string>;
	accountId: string;
	xKillbillCreatedBy: string;
	xKillbillReason?: string;
	xKillbillComment?: string;
}

export interface CreatePaymentMethodRequest {
	body: PaymentMethod;
	accountId: string;
	xKillbillCreatedBy: string;
	isDefault?: boolean;
	payAllUnpaidInvoices?: boolean;
	controlPluginName?: Array<string>;
	pluginProperty?: Array<string>;
	xKillbillReason?: string;
	xKillbillComment?: string;
}

export interface DeleteAccountCustomFieldsRequest {
	accountId: string;
	xKillbillCreatedBy: string;
	customField?: Array<string>;
	xKillbillReason?: string;
	xKillbillComment?: string;
}

export interface DeleteAccountTagsRequest {
	accountId: string;
	xKillbillCreatedBy: string;
	tagDef?: Array<string>;
	xKillbillReason?: string;
	xKillbillComment?: string;
}

export interface GetAccountRequest {
	accountId: string;
	accountWithBalance?: boolean;
	accountWithBalanceAndCBA?: boolean;
	audit?: GetAccountAuditEnum;
}

export interface GetAccountAuditLogsRequest {
	accountId: string;
}

export interface GetAccountAuditLogsWithHistoryRequest {
	accountId: string;
}

export interface GetAccountBundlesRequest {
	accountId: string;
	externalKey?: string;
	bundlesFilter?: string;
	audit?: GetAccountBundlesAuditEnum;
}

export interface GetAccountBundlesPaginatedRequest {
	accountId: string;
	offset?: number;
	limit?: number;
	audit?: GetAccountBundlesPaginatedAuditEnum;
}

export interface GetAccountByKeyRequest {
	externalKey: string;
	accountWithBalance?: boolean;
	accountWithBalanceAndCBA?: boolean;
	audit?: GetAccountByKeyAuditEnum;
}

export interface GetAccountCustomFieldsRequest {
	accountId: string;
	audit?: GetAccountCustomFieldsAuditEnum;
}

export interface GetAccountEmailAuditLogsWithHistoryRequest {
	accountId: string;
	accountEmailId: string;
}

export interface GetAccountTagsRequest {
	accountId: string;
	includedDeleted?: boolean;
	audit?: GetAccountTagsAuditEnum;
}

export interface GetAccountTimelineRequest {
	accountId: string;
	parallel?: boolean;
	audit?: GetAccountTimelineAuditEnum;
}

export interface GetAccountsRequest {
	offset?: number;
	limit?: number;
	accountWithBalance?: boolean;
	accountWithBalanceAndCBA?: boolean;
	audit?: GetAccountsAuditEnum;
}

export interface GetAllCustomFieldsRequest {
	accountId: string;
	objectType?: GetAllCustomFieldsObjectTypeEnum;
	audit?: GetAllCustomFieldsAuditEnum;
}

export interface GetAllTagsRequest {
	accountId: string;
	objectType?: GetAllTagsObjectTypeEnum;
	includedDeleted?: boolean;
	audit?: GetAllTagsAuditEnum;
}

export interface GetBlockingStateAuditLogsWithHistoryRequest {
	blockingId: string;
}

export interface GetBlockingStatesRequest {
	accountId: string;
	blockingStateTypes?: Array<GetBlockingStatesBlockingStateTypesEnum>;
	blockingStateSvcs?: Array<string>;
	audit?: GetBlockingStatesAuditEnum;
}

export interface GetChildrenAccountsRequest {
	accountId: string;
	accountWithBalance?: boolean;
	accountWithBalanceAndCBA?: boolean;
	audit?: GetChildrenAccountsAuditEnum;
}

export interface GetEmailsRequest {
	accountId: string;
}

export interface GetInvoicePaymentsRequest {
	accountId: string;
	withPluginInfo?: boolean;
	withAttempts?: boolean;
	pluginProperty?: Array<string>;
	audit?: GetInvoicePaymentsAuditEnum;
}

export interface GetInvoicesForAccountRequest {
	accountId: string;
	startDate?: Date;
	endDate?: Date;
	withMigrationInvoices?: boolean;
	unpaidInvoicesOnly?: boolean;
	includeVoidedInvoices?: boolean;
	includeInvoiceComponents?: boolean;
	invoicesFilter?: string;
	audit?: GetInvoicesForAccountAuditEnum;
}

export interface GetInvoicesForAccountPaginatedRequest {
	accountId: string;
	offset?: number;
	limit?: number;
	audit?: GetInvoicesForAccountPaginatedAuditEnum;
}

export interface GetOverdueAccountRequest {
	accountId: string;
}

export interface GetPaymentMethodsForAccountRequest {
	accountId: string;
	withPluginInfo?: boolean;
	includedDeleted?: boolean;
	pluginProperty?: Array<string>;
	audit?: GetPaymentMethodsForAccountAuditEnum;
}

export interface GetPaymentsForAccountRequest {
	accountId: string;
	withAttempts?: boolean;
	withPluginInfo?: boolean;
	pluginProperty?: Array<string>;
	audit?: GetPaymentsForAccountAuditEnum;
}

export interface ModifyAccountCustomFieldsRequest {
	body: Array<CustomField>;
	accountId: string;
	xKillbillCreatedBy: string;
	xKillbillReason?: string;
	xKillbillComment?: string;
}

export interface PayAllInvoicesRequest {
	accountId: string;
	xKillbillCreatedBy: string;
	paymentMethodId?: string;
	externalPayment?: boolean;
	paymentAmount?: number;
	targetDate?: Date;
	pluginProperty?: Array<string>;
	xKillbillReason?: string;
	xKillbillComment?: string;
}

export interface ProcessPaymentRequest {
	body: PaymentTransaction;
	accountId: string;
	xKillbillCreatedBy: string;
	paymentMethodId?: string;
	controlPluginName?: Array<string>;
	pluginProperty?: Array<string>;
	xKillbillReason?: string;
	xKillbillComment?: string;
}

export interface ProcessPaymentByExternalKeyRequest {
	body: PaymentTransaction;
	externalKey: string;
	xKillbillCreatedBy: string;
	paymentMethodId?: string;
	controlPluginName?: Array<string>;
	pluginProperty?: Array<string>;
	xKillbillReason?: string;
	xKillbillComment?: string;
}

export interface RebalanceExistingCBAOnAccountRequest {
	accountId: string;
	xKillbillCreatedBy: string;
	xKillbillReason?: string;
	xKillbillComment?: string;
}

export interface RefreshPaymentMethodsRequest {
	accountId: string;
	xKillbillCreatedBy: string;
	pluginName?: string;
	pluginProperty?: Array<string>;
	xKillbillReason?: string;
	xKillbillComment?: string;
}

export interface RemoveEmailRequest {
	accountId: string;
	email: string;
	xKillbillCreatedBy: string;
	xKillbillReason?: string;
	xKillbillComment?: string;
}

export interface SearchAccountsRequest {
	searchKey: string;
	offset?: number;
	limit?: number;
	accountWithBalance?: boolean;
	accountWithBalanceAndCBA?: boolean;
	audit?: SearchAccountsAuditEnum;
}

export interface SetDefaultPaymentMethodRequest {
	accountId: string;
	paymentMethodId: string;
	xKillbillCreatedBy: string;
	payAllUnpaidInvoices?: boolean;
	pluginProperty?: Array<string>;
	xKillbillReason?: string;
	xKillbillComment?: string;
}

export interface TransferChildCreditToParentRequest {
	childAccountId: string;
	xKillbillCreatedBy: string;
	xKillbillReason?: string;
	xKillbillComment?: string;
}

export interface UpdateAccountRequest {
	body: Account;
	accountId: string;
	xKillbillCreatedBy: string;
	treatNullAsReset?: boolean;
	xKillbillReason?: string;
	xKillbillComment?: string;
}

/**
 *
 */
export class AccountApi extends runtime.BaseAPI {
	/**
	 * Block an account
	 */
	async addAccountBlockingStateRaw(
		requestParameters: AddAccountBlockingStateRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<Array<BlockingState>>> {
		if (requestParameters.body === null || requestParameters.body === undefined) {
			throw new runtime.RequiredError(
				'body',
				'Required parameter requestParameters.body was null or undefined when calling addAccountBlockingState.'
			);
		}

		if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
			throw new runtime.RequiredError(
				'accountId',
				'Required parameter requestParameters.accountId was null or undefined when calling addAccountBlockingState.'
			);
		}

		if (
			requestParameters.xKillbillCreatedBy === null ||
			requestParameters.xKillbillCreatedBy === undefined
		) {
			throw new runtime.RequiredError(
				'xKillbillCreatedBy',
				'Required parameter requestParameters.xKillbillCreatedBy was null or undefined when calling addAccountBlockingState.'
			);
		}

		const queryParameters: any = {};

		if (requestParameters.requestedDate !== undefined) {
			queryParameters['requestedDate'] = (requestParameters.requestedDate as any)
				.toISOString()
				.substr(0, 10);
		}

		if (requestParameters.pluginProperty) {
			queryParameters['pluginProperty'] = requestParameters.pluginProperty;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters['Content-Type'] = 'application/json';

		if (
			requestParameters.xKillbillCreatedBy !== undefined &&
			requestParameters.xKillbillCreatedBy !== null
		) {
			headerParameters['X-Killbill-CreatedBy'] = String(requestParameters.xKillbillCreatedBy);
		}

		if (
			requestParameters.xKillbillReason !== undefined &&
			requestParameters.xKillbillReason !== null
		) {
			headerParameters['X-Killbill-Reason'] = String(requestParameters.xKillbillReason);
		}

		if (
			requestParameters.xKillbillComment !== undefined &&
			requestParameters.xKillbillComment !== null
		) {
			headerParameters['X-Killbill-Comment'] = String(requestParameters.xKillbillComment);
		}

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiKey'] = this.configuration.apiKey('X-Killbill-ApiKey'); // Killbill Api Key authentication
		}

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiSecret'] = this.configuration.apiKey('X-Killbill-ApiSecret'); // Killbill Api Secret authentication
		}

		if (
			this.configuration &&
			(this.configuration.username !== undefined || this.configuration.password !== undefined)
		) {
			headerParameters['Authorization'] =
				'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
		}
		const response = await this.request(
			{
				path: `/1.0/kb/accounts/{accountId}/block`.replace(
					`{${'accountId'}}`,
					encodeURIComponent(String(requestParameters.accountId))
				),
				method: 'POST',
				headers: headerParameters,
				query: queryParameters,
				body: BlockingStateToJSON(requestParameters.body)
			},
			initOverrides
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			jsonValue.map(BlockingStateFromJSON)
		);
	}

	/**
	 * Block an account
	 */
	async addAccountBlockingState(
		requestParameters: AddAccountBlockingStateRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<Array<BlockingState>> {
		const response = await this.addAccountBlockingStateRaw(requestParameters, initOverrides);
		return await response.value();
	}

	/**
	 * Add account email
	 */
	async addEmailRaw(
		requestParameters: AddEmailRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<Array<AccountEmail>>> {
		if (requestParameters.body === null || requestParameters.body === undefined) {
			throw new runtime.RequiredError(
				'body',
				'Required parameter requestParameters.body was null or undefined when calling addEmail.'
			);
		}

		if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
			throw new runtime.RequiredError(
				'accountId',
				'Required parameter requestParameters.accountId was null or undefined when calling addEmail.'
			);
		}

		if (
			requestParameters.xKillbillCreatedBy === null ||
			requestParameters.xKillbillCreatedBy === undefined
		) {
			throw new runtime.RequiredError(
				'xKillbillCreatedBy',
				'Required parameter requestParameters.xKillbillCreatedBy was null or undefined when calling addEmail.'
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters['Content-Type'] = 'application/json';

		if (
			requestParameters.xKillbillCreatedBy !== undefined &&
			requestParameters.xKillbillCreatedBy !== null
		) {
			headerParameters['X-Killbill-CreatedBy'] = String(requestParameters.xKillbillCreatedBy);
		}

		if (
			requestParameters.xKillbillReason !== undefined &&
			requestParameters.xKillbillReason !== null
		) {
			headerParameters['X-Killbill-Reason'] = String(requestParameters.xKillbillReason);
		}

		if (
			requestParameters.xKillbillComment !== undefined &&
			requestParameters.xKillbillComment !== null
		) {
			headerParameters['X-Killbill-Comment'] = String(requestParameters.xKillbillComment);
		}

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiKey'] = this.configuration.apiKey('X-Killbill-ApiKey'); // Killbill Api Key authentication
		}

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiSecret'] = this.configuration.apiKey('X-Killbill-ApiSecret'); // Killbill Api Secret authentication
		}

		if (
			this.configuration &&
			(this.configuration.username !== undefined || this.configuration.password !== undefined)
		) {
			headerParameters['Authorization'] =
				'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
		}
		const response = await this.request(
			{
				path: `/1.0/kb/accounts/{accountId}/emails`.replace(
					`{${'accountId'}}`,
					encodeURIComponent(String(requestParameters.accountId))
				),
				method: 'POST',
				headers: headerParameters,
				query: queryParameters,
				body: AccountEmailToJSON(requestParameters.body)
			},
			initOverrides
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			jsonValue.map(AccountEmailFromJSON)
		);
	}

	/**
	 * Add account email
	 */
	async addEmail(
		requestParameters: AddEmailRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<Array<AccountEmail>> {
		const response = await this.addEmailRaw(requestParameters, initOverrides);
		return await response.value();
	}

	/**
	 * Close account
	 */
	async closeAccountRaw(
		requestParameters: CloseAccountRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<void>> {
		if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
			throw new runtime.RequiredError(
				'accountId',
				'Required parameter requestParameters.accountId was null or undefined when calling closeAccount.'
			);
		}

		if (
			requestParameters.xKillbillCreatedBy === null ||
			requestParameters.xKillbillCreatedBy === undefined
		) {
			throw new runtime.RequiredError(
				'xKillbillCreatedBy',
				'Required parameter requestParameters.xKillbillCreatedBy was null or undefined when calling closeAccount.'
			);
		}

		const queryParameters: any = {};

		if (requestParameters.cancelAllSubscriptions !== undefined) {
			queryParameters['cancelAllSubscriptions'] = requestParameters.cancelAllSubscriptions;
		}

		if (requestParameters.writeOffUnpaidInvoices !== undefined) {
			queryParameters['writeOffUnpaidInvoices'] = requestParameters.writeOffUnpaidInvoices;
		}

		if (requestParameters.itemAdjustUnpaidInvoices !== undefined) {
			queryParameters['itemAdjustUnpaidInvoices'] = requestParameters.itemAdjustUnpaidInvoices;
		}

		if (requestParameters.removeFutureNotifications !== undefined) {
			queryParameters['removeFutureNotifications'] = requestParameters.removeFutureNotifications;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (
			requestParameters.xKillbillCreatedBy !== undefined &&
			requestParameters.xKillbillCreatedBy !== null
		) {
			headerParameters['X-Killbill-CreatedBy'] = String(requestParameters.xKillbillCreatedBy);
		}

		if (
			requestParameters.xKillbillReason !== undefined &&
			requestParameters.xKillbillReason !== null
		) {
			headerParameters['X-Killbill-Reason'] = String(requestParameters.xKillbillReason);
		}

		if (
			requestParameters.xKillbillComment !== undefined &&
			requestParameters.xKillbillComment !== null
		) {
			headerParameters['X-Killbill-Comment'] = String(requestParameters.xKillbillComment);
		}

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiKey'] = this.configuration.apiKey('X-Killbill-ApiKey'); // Killbill Api Key authentication
		}

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiSecret'] = this.configuration.apiKey('X-Killbill-ApiSecret'); // Killbill Api Secret authentication
		}

		if (
			this.configuration &&
			(this.configuration.username !== undefined || this.configuration.password !== undefined)
		) {
			headerParameters['Authorization'] =
				'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
		}
		const response = await this.request(
			{
				path: `/1.0/kb/accounts/{accountId}`.replace(
					`{${'accountId'}}`,
					encodeURIComponent(String(requestParameters.accountId))
				),
				method: 'DELETE',
				headers: headerParameters,
				query: queryParameters
			},
			initOverrides
		);

		return new runtime.VoidApiResponse(response);
	}

	/**
	 * Close account
	 */
	async closeAccount(
		requestParameters: CloseAccountRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<void> {
		await this.closeAccountRaw(requestParameters, initOverrides);
	}

	/**
	 * Create account
	 */
	async createAccountRaw(
		requestParameters: CreateAccountRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<Account>> {
		if (requestParameters.body === null || requestParameters.body === undefined) {
			throw new runtime.RequiredError(
				'body',
				'Required parameter requestParameters.body was null or undefined when calling createAccount.'
			);
		}

		if (
			requestParameters.xKillbillCreatedBy === null ||
			requestParameters.xKillbillCreatedBy === undefined
		) {
			throw new runtime.RequiredError(
				'xKillbillCreatedBy',
				'Required parameter requestParameters.xKillbillCreatedBy was null or undefined when calling createAccount.'
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters['Content-Type'] = 'application/json';

		if (
			requestParameters.xKillbillCreatedBy !== undefined &&
			requestParameters.xKillbillCreatedBy !== null
		) {
			headerParameters['X-Killbill-CreatedBy'] = String(requestParameters.xKillbillCreatedBy);
		}

		if (
			requestParameters.xKillbillReason !== undefined &&
			requestParameters.xKillbillReason !== null
		) {
			headerParameters['X-Killbill-Reason'] = String(requestParameters.xKillbillReason);
		}

		if (
			requestParameters.xKillbillComment !== undefined &&
			requestParameters.xKillbillComment !== null
		) {
			headerParameters['X-Killbill-Comment'] = String(requestParameters.xKillbillComment);
		}

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiKey'] = this.configuration.apiKey('X-Killbill-ApiKey'); // Killbill Api Key authentication
		}

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiSecret'] = this.configuration.apiKey('X-Killbill-ApiSecret'); // Killbill Api Secret authentication
		}

		if (
			this.configuration &&
			(this.configuration.username !== undefined || this.configuration.password !== undefined)
		) {
			headerParameters['Authorization'] =
				'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
		}
		const response = await this.request(
			{
				path: `/1.0/kb/accounts`,
				method: 'POST',
				headers: headerParameters,
				query: queryParameters,
				body: AccountToJSON(requestParameters.body)
			},
			initOverrides
		);

		return new runtime.JSONApiResponse(response, (jsonValue) => AccountFromJSON(jsonValue));
	}

	/**
	 * Create account
	 */
	async createAccount(
		requestParameters: CreateAccountRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<Account> {
		const response = await this.createAccountRaw(requestParameters, initOverrides);
		return await response.value();
	}

	/**
	 * Add custom fields to account
	 */
	async createAccountCustomFieldsRaw(
		requestParameters: CreateAccountCustomFieldsRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<Array<CustomField>>> {
		if (requestParameters.body === null || requestParameters.body === undefined) {
			throw new runtime.RequiredError(
				'body',
				'Required parameter requestParameters.body was null or undefined when calling createAccountCustomFields.'
			);
		}

		if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
			throw new runtime.RequiredError(
				'accountId',
				'Required parameter requestParameters.accountId was null or undefined when calling createAccountCustomFields.'
			);
		}

		if (
			requestParameters.xKillbillCreatedBy === null ||
			requestParameters.xKillbillCreatedBy === undefined
		) {
			throw new runtime.RequiredError(
				'xKillbillCreatedBy',
				'Required parameter requestParameters.xKillbillCreatedBy was null or undefined when calling createAccountCustomFields.'
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters['Content-Type'] = 'application/json';

		if (
			requestParameters.xKillbillCreatedBy !== undefined &&
			requestParameters.xKillbillCreatedBy !== null
		) {
			headerParameters['X-Killbill-CreatedBy'] = String(requestParameters.xKillbillCreatedBy);
		}

		if (
			requestParameters.xKillbillReason !== undefined &&
			requestParameters.xKillbillReason !== null
		) {
			headerParameters['X-Killbill-Reason'] = String(requestParameters.xKillbillReason);
		}

		if (
			requestParameters.xKillbillComment !== undefined &&
			requestParameters.xKillbillComment !== null
		) {
			headerParameters['X-Killbill-Comment'] = String(requestParameters.xKillbillComment);
		}

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiKey'] = this.configuration.apiKey('X-Killbill-ApiKey'); // Killbill Api Key authentication
		}

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiSecret'] = this.configuration.apiKey('X-Killbill-ApiSecret'); // Killbill Api Secret authentication
		}

		if (
			this.configuration &&
			(this.configuration.username !== undefined || this.configuration.password !== undefined)
		) {
			headerParameters['Authorization'] =
				'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
		}
		const response = await this.request(
			{
				path: `/1.0/kb/accounts/{accountId}/customFields`.replace(
					`{${'accountId'}}`,
					encodeURIComponent(String(requestParameters.accountId))
				),
				method: 'POST',
				headers: headerParameters,
				query: queryParameters,
				body: requestParameters.body.map(CustomFieldToJSON)
			},
			initOverrides
		);

		return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(CustomFieldFromJSON));
	}

	/**
	 * Add custom fields to account
	 */
	async createAccountCustomFields(
		requestParameters: CreateAccountCustomFieldsRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<Array<CustomField>> {
		const response = await this.createAccountCustomFieldsRaw(requestParameters, initOverrides);
		return await response.value();
	}

	/**
	 * Add tags to account
	 */
	async createAccountTagsRaw(
		requestParameters: CreateAccountTagsRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<Array<Tag>>> {
		if (requestParameters.body === null || requestParameters.body === undefined) {
			throw new runtime.RequiredError(
				'body',
				'Required parameter requestParameters.body was null or undefined when calling createAccountTags.'
			);
		}

		if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
			throw new runtime.RequiredError(
				'accountId',
				'Required parameter requestParameters.accountId was null or undefined when calling createAccountTags.'
			);
		}

		if (
			requestParameters.xKillbillCreatedBy === null ||
			requestParameters.xKillbillCreatedBy === undefined
		) {
			throw new runtime.RequiredError(
				'xKillbillCreatedBy',
				'Required parameter requestParameters.xKillbillCreatedBy was null or undefined when calling createAccountTags.'
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters['Content-Type'] = 'application/json';

		if (
			requestParameters.xKillbillCreatedBy !== undefined &&
			requestParameters.xKillbillCreatedBy !== null
		) {
			headerParameters['X-Killbill-CreatedBy'] = String(requestParameters.xKillbillCreatedBy);
		}

		if (
			requestParameters.xKillbillReason !== undefined &&
			requestParameters.xKillbillReason !== null
		) {
			headerParameters['X-Killbill-Reason'] = String(requestParameters.xKillbillReason);
		}

		if (
			requestParameters.xKillbillComment !== undefined &&
			requestParameters.xKillbillComment !== null
		) {
			headerParameters['X-Killbill-Comment'] = String(requestParameters.xKillbillComment);
		}

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiKey'] = this.configuration.apiKey('X-Killbill-ApiKey'); // Killbill Api Key authentication
		}

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiSecret'] = this.configuration.apiKey('X-Killbill-ApiSecret'); // Killbill Api Secret authentication
		}

		if (
			this.configuration &&
			(this.configuration.username !== undefined || this.configuration.password !== undefined)
		) {
			headerParameters['Authorization'] =
				'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
		}
		const response = await this.request(
			{
				path: `/1.0/kb/accounts/{accountId}/tags`.replace(
					`{${'accountId'}}`,
					encodeURIComponent(String(requestParameters.accountId))
				),
				method: 'POST',
				headers: headerParameters,
				query: queryParameters,
				body: requestParameters.body
			},
			initOverrides
		);

		return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TagFromJSON));
	}

	/**
	 * Add tags to account
	 */
	async createAccountTags(
		requestParameters: CreateAccountTagsRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<Array<Tag>> {
		const response = await this.createAccountTagsRaw(requestParameters, initOverrides);
		return await response.value();
	}

	/**
	 * Add a payment method
	 */
	async createPaymentMethodRaw(
		requestParameters: CreatePaymentMethodRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<PaymentMethod>> {
		if (requestParameters.body === null || requestParameters.body === undefined) {
			throw new runtime.RequiredError(
				'body',
				'Required parameter requestParameters.body was null or undefined when calling createPaymentMethod.'
			);
		}

		if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
			throw new runtime.RequiredError(
				'accountId',
				'Required parameter requestParameters.accountId was null or undefined when calling createPaymentMethod.'
			);
		}

		if (
			requestParameters.xKillbillCreatedBy === null ||
			requestParameters.xKillbillCreatedBy === undefined
		) {
			throw new runtime.RequiredError(
				'xKillbillCreatedBy',
				'Required parameter requestParameters.xKillbillCreatedBy was null or undefined when calling createPaymentMethod.'
			);
		}

		const queryParameters: any = {};

		if (requestParameters.isDefault !== undefined) {
			queryParameters['isDefault'] = requestParameters.isDefault;
		}

		if (requestParameters.payAllUnpaidInvoices !== undefined) {
			queryParameters['payAllUnpaidInvoices'] = requestParameters.payAllUnpaidInvoices;
		}

		if (requestParameters.controlPluginName) {
			queryParameters['controlPluginName'] = requestParameters.controlPluginName;
		}

		if (requestParameters.pluginProperty) {
			queryParameters['pluginProperty'] = requestParameters.pluginProperty;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters['Content-Type'] = 'application/json';

		if (
			requestParameters.xKillbillCreatedBy !== undefined &&
			requestParameters.xKillbillCreatedBy !== null
		) {
			headerParameters['X-Killbill-CreatedBy'] = String(requestParameters.xKillbillCreatedBy);
		}

		if (
			requestParameters.xKillbillReason !== undefined &&
			requestParameters.xKillbillReason !== null
		) {
			headerParameters['X-Killbill-Reason'] = String(requestParameters.xKillbillReason);
		}

		if (
			requestParameters.xKillbillComment !== undefined &&
			requestParameters.xKillbillComment !== null
		) {
			headerParameters['X-Killbill-Comment'] = String(requestParameters.xKillbillComment);
		}

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiKey'] = this.configuration.apiKey('X-Killbill-ApiKey'); // Killbill Api Key authentication
		}

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiSecret'] = this.configuration.apiKey('X-Killbill-ApiSecret'); // Killbill Api Secret authentication
		}

		if (
			this.configuration &&
			(this.configuration.username !== undefined || this.configuration.password !== undefined)
		) {
			headerParameters['Authorization'] =
				'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
		}
		const response = await this.request(
			{
				path: `/1.0/kb/accounts/{accountId}/paymentMethods`.replace(
					`{${'accountId'}}`,
					encodeURIComponent(String(requestParameters.accountId))
				),
				method: 'POST',
				headers: headerParameters,
				query: queryParameters,
				body: PaymentMethodToJSON(requestParameters.body)
			},
			initOverrides
		);

		return new runtime.JSONApiResponse(response, (jsonValue) => PaymentMethodFromJSON(jsonValue));
	}

	/**
	 * Add a payment method
	 */
	async createPaymentMethod(
		requestParameters: CreatePaymentMethodRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<PaymentMethod> {
		const response = await this.createPaymentMethodRaw(requestParameters, initOverrides);
		return await response.value();
	}

	/**
	 * Remove custom fields from account
	 */
	async deleteAccountCustomFieldsRaw(
		requestParameters: DeleteAccountCustomFieldsRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<void>> {
		if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
			throw new runtime.RequiredError(
				'accountId',
				'Required parameter requestParameters.accountId was null or undefined when calling deleteAccountCustomFields.'
			);
		}

		if (
			requestParameters.xKillbillCreatedBy === null ||
			requestParameters.xKillbillCreatedBy === undefined
		) {
			throw new runtime.RequiredError(
				'xKillbillCreatedBy',
				'Required parameter requestParameters.xKillbillCreatedBy was null or undefined when calling deleteAccountCustomFields.'
			);
		}

		const queryParameters: any = {};

		if (requestParameters.customField) {
			queryParameters['customField'] = requestParameters.customField;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (
			requestParameters.xKillbillCreatedBy !== undefined &&
			requestParameters.xKillbillCreatedBy !== null
		) {
			headerParameters['X-Killbill-CreatedBy'] = String(requestParameters.xKillbillCreatedBy);
		}

		if (
			requestParameters.xKillbillReason !== undefined &&
			requestParameters.xKillbillReason !== null
		) {
			headerParameters['X-Killbill-Reason'] = String(requestParameters.xKillbillReason);
		}

		if (
			requestParameters.xKillbillComment !== undefined &&
			requestParameters.xKillbillComment !== null
		) {
			headerParameters['X-Killbill-Comment'] = String(requestParameters.xKillbillComment);
		}

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiKey'] = this.configuration.apiKey('X-Killbill-ApiKey'); // Killbill Api Key authentication
		}

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiSecret'] = this.configuration.apiKey('X-Killbill-ApiSecret'); // Killbill Api Secret authentication
		}

		if (
			this.configuration &&
			(this.configuration.username !== undefined || this.configuration.password !== undefined)
		) {
			headerParameters['Authorization'] =
				'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
		}
		const response = await this.request(
			{
				path: `/1.0/kb/accounts/{accountId}/customFields`.replace(
					`{${'accountId'}}`,
					encodeURIComponent(String(requestParameters.accountId))
				),
				method: 'DELETE',
				headers: headerParameters,
				query: queryParameters
			},
			initOverrides
		);

		return new runtime.VoidApiResponse(response);
	}

	/**
	 * Remove custom fields from account
	 */
	async deleteAccountCustomFields(
		requestParameters: DeleteAccountCustomFieldsRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<void> {
		await this.deleteAccountCustomFieldsRaw(requestParameters, initOverrides);
	}

	/**
	 * Remove tags from account
	 */
	async deleteAccountTagsRaw(
		requestParameters: DeleteAccountTagsRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<void>> {
		if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
			throw new runtime.RequiredError(
				'accountId',
				'Required parameter requestParameters.accountId was null or undefined when calling deleteAccountTags.'
			);
		}

		if (
			requestParameters.xKillbillCreatedBy === null ||
			requestParameters.xKillbillCreatedBy === undefined
		) {
			throw new runtime.RequiredError(
				'xKillbillCreatedBy',
				'Required parameter requestParameters.xKillbillCreatedBy was null or undefined when calling deleteAccountTags.'
			);
		}

		const queryParameters: any = {};

		if (requestParameters.tagDef) {
			queryParameters['tagDef'] = requestParameters.tagDef;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (
			requestParameters.xKillbillCreatedBy !== undefined &&
			requestParameters.xKillbillCreatedBy !== null
		) {
			headerParameters['X-Killbill-CreatedBy'] = String(requestParameters.xKillbillCreatedBy);
		}

		if (
			requestParameters.xKillbillReason !== undefined &&
			requestParameters.xKillbillReason !== null
		) {
			headerParameters['X-Killbill-Reason'] = String(requestParameters.xKillbillReason);
		}

		if (
			requestParameters.xKillbillComment !== undefined &&
			requestParameters.xKillbillComment !== null
		) {
			headerParameters['X-Killbill-Comment'] = String(requestParameters.xKillbillComment);
		}

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiKey'] = this.configuration.apiKey('X-Killbill-ApiKey'); // Killbill Api Key authentication
		}

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiSecret'] = this.configuration.apiKey('X-Killbill-ApiSecret'); // Killbill Api Secret authentication
		}

		if (
			this.configuration &&
			(this.configuration.username !== undefined || this.configuration.password !== undefined)
		) {
			headerParameters['Authorization'] =
				'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
		}
		const response = await this.request(
			{
				path: `/1.0/kb/accounts/{accountId}/tags`.replace(
					`{${'accountId'}}`,
					encodeURIComponent(String(requestParameters.accountId))
				),
				method: 'DELETE',
				headers: headerParameters,
				query: queryParameters
			},
			initOverrides
		);

		return new runtime.VoidApiResponse(response);
	}

	/**
	 * Remove tags from account
	 */
	async deleteAccountTags(
		requestParameters: DeleteAccountTagsRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<void> {
		await this.deleteAccountTagsRaw(requestParameters, initOverrides);
	}

	/**
	 * Retrieve an account by id
	 */
	async getAccountRaw(
		requestParameters: GetAccountRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<Account>> {
		if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
			throw new runtime.RequiredError(
				'accountId',
				'Required parameter requestParameters.accountId was null or undefined when calling getAccount.'
			);
		}

		const queryParameters: any = {};

		if (requestParameters.accountWithBalance !== undefined) {
			queryParameters['accountWithBalance'] = requestParameters.accountWithBalance;
		}

		if (requestParameters.accountWithBalanceAndCBA !== undefined) {
			queryParameters['accountWithBalanceAndCBA'] = requestParameters.accountWithBalanceAndCBA;
		}

		if (requestParameters.audit !== undefined) {
			queryParameters['audit'] = requestParameters.audit;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiKey'] = this.configuration.apiKey('X-Killbill-ApiKey'); // Killbill Api Key authentication
		}

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiSecret'] = this.configuration.apiKey('X-Killbill-ApiSecret'); // Killbill Api Secret authentication
		}

		if (
			this.configuration &&
			(this.configuration.username !== undefined || this.configuration.password !== undefined)
		) {
			headerParameters['Authorization'] =
				'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
		}
		const response = await this.request(
			{
				path: `/1.0/kb/accounts/{accountId}`.replace(
					`{${'accountId'}}`,
					encodeURIComponent(String(requestParameters.accountId))
				),
				method: 'GET',
				headers: headerParameters,
				query: queryParameters
			},
			initOverrides
		);

		return new runtime.JSONApiResponse(response, (jsonValue) => AccountFromJSON(jsonValue));
	}

	/**
	 * Retrieve an account by id
	 */
	async getAccount(
		requestParameters: GetAccountRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<Account> {
		const response = await this.getAccountRaw(requestParameters, initOverrides);
		return await response.value();
	}

	/**
	 * Retrieve audit logs by account id
	 */
	async getAccountAuditLogsRaw(
		requestParameters: GetAccountAuditLogsRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<Array<AuditLog>>> {
		if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
			throw new runtime.RequiredError(
				'accountId',
				'Required parameter requestParameters.accountId was null or undefined when calling getAccountAuditLogs.'
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiKey'] = this.configuration.apiKey('X-Killbill-ApiKey'); // Killbill Api Key authentication
		}

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiSecret'] = this.configuration.apiKey('X-Killbill-ApiSecret'); // Killbill Api Secret authentication
		}

		if (
			this.configuration &&
			(this.configuration.username !== undefined || this.configuration.password !== undefined)
		) {
			headerParameters['Authorization'] =
				'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
		}
		const response = await this.request(
			{
				path: `/1.0/kb/accounts/{accountId}/auditLogs`.replace(
					`{${'accountId'}}`,
					encodeURIComponent(String(requestParameters.accountId))
				),
				method: 'GET',
				headers: headerParameters,
				query: queryParameters
			},
			initOverrides
		);

		return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(AuditLogFromJSON));
	}

	/**
	 * Retrieve audit logs by account id
	 */
	async getAccountAuditLogs(
		requestParameters: GetAccountAuditLogsRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<Array<AuditLog>> {
		const response = await this.getAccountAuditLogsRaw(requestParameters, initOverrides);
		return await response.value();
	}

	/**
	 * Retrieve account audit logs with history by account id
	 */
	async getAccountAuditLogsWithHistoryRaw(
		requestParameters: GetAccountAuditLogsWithHistoryRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<Array<AuditLog>>> {
		if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
			throw new runtime.RequiredError(
				'accountId',
				'Required parameter requestParameters.accountId was null or undefined when calling getAccountAuditLogsWithHistory.'
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiKey'] = this.configuration.apiKey('X-Killbill-ApiKey'); // Killbill Api Key authentication
		}

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiSecret'] = this.configuration.apiKey('X-Killbill-ApiSecret'); // Killbill Api Secret authentication
		}

		if (
			this.configuration &&
			(this.configuration.username !== undefined || this.configuration.password !== undefined)
		) {
			headerParameters['Authorization'] =
				'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
		}
		const response = await this.request(
			{
				path: `/1.0/kb/accounts/{accountId}/auditLogsWithHistory`.replace(
					`{${'accountId'}}`,
					encodeURIComponent(String(requestParameters.accountId))
				),
				method: 'GET',
				headers: headerParameters,
				query: queryParameters
			},
			initOverrides
		);

		return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(AuditLogFromJSON));
	}

	/**
	 * Retrieve account audit logs with history by account id
	 */
	async getAccountAuditLogsWithHistory(
		requestParameters: GetAccountAuditLogsWithHistoryRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<Array<AuditLog>> {
		const response = await this.getAccountAuditLogsWithHistoryRaw(requestParameters, initOverrides);
		return await response.value();
	}

	/**
	 * Retrieve bundles for account
	 */
	async getAccountBundlesRaw(
		requestParameters: GetAccountBundlesRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<Array<Bundle>>> {
		if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
			throw new runtime.RequiredError(
				'accountId',
				'Required parameter requestParameters.accountId was null or undefined when calling getAccountBundles.'
			);
		}

		const queryParameters: any = {};

		if (requestParameters.externalKey !== undefined) {
			queryParameters['externalKey'] = requestParameters.externalKey;
		}

		if (requestParameters.bundlesFilter !== undefined) {
			queryParameters['bundlesFilter'] = requestParameters.bundlesFilter;
		}

		if (requestParameters.audit !== undefined) {
			queryParameters['audit'] = requestParameters.audit;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiKey'] = this.configuration.apiKey('X-Killbill-ApiKey'); // Killbill Api Key authentication
		}

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiSecret'] = this.configuration.apiKey('X-Killbill-ApiSecret'); // Killbill Api Secret authentication
		}

		if (
			this.configuration &&
			(this.configuration.username !== undefined || this.configuration.password !== undefined)
		) {
			headerParameters['Authorization'] =
				'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
		}
		const response = await this.request(
			{
				path: `/1.0/kb/accounts/{accountId}/bundles`.replace(
					`{${'accountId'}}`,
					encodeURIComponent(String(requestParameters.accountId))
				),
				method: 'GET',
				headers: headerParameters,
				query: queryParameters
			},
			initOverrides
		);

		return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(BundleFromJSON));
	}

	/**
	 * Retrieve bundles for account
	 */
	async getAccountBundles(
		requestParameters: GetAccountBundlesRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<Array<Bundle>> {
		const response = await this.getAccountBundlesRaw(requestParameters, initOverrides);
		return await response.value();
	}

	/**
	 * Retrieve paginated bundles for account
	 */
	async getAccountBundlesPaginatedRaw(
		requestParameters: GetAccountBundlesPaginatedRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<Array<Bundle>>> {
		if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
			throw new runtime.RequiredError(
				'accountId',
				'Required parameter requestParameters.accountId was null or undefined when calling getAccountBundlesPaginated.'
			);
		}

		const queryParameters: any = {};

		if (requestParameters.offset !== undefined) {
			queryParameters['offset'] = requestParameters.offset;
		}

		if (requestParameters.limit !== undefined) {
			queryParameters['limit'] = requestParameters.limit;
		}

		if (requestParameters.audit !== undefined) {
			queryParameters['audit'] = requestParameters.audit;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiKey'] = this.configuration.apiKey('X-Killbill-ApiKey'); // Killbill Api Key authentication
		}

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiSecret'] = this.configuration.apiKey('X-Killbill-ApiSecret'); // Killbill Api Secret authentication
		}

		if (
			this.configuration &&
			(this.configuration.username !== undefined || this.configuration.password !== undefined)
		) {
			headerParameters['Authorization'] =
				'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
		}
		const response = await this.request(
			{
				path: `/1.0/kb/accounts/{accountId}/bundles/pagination`.replace(
					`{${'accountId'}}`,
					encodeURIComponent(String(requestParameters.accountId))
				),
				method: 'GET',
				headers: headerParameters,
				query: queryParameters
			},
			initOverrides
		);

		return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(BundleFromJSON));
	}

	/**
	 * Retrieve paginated bundles for account
	 */
	async getAccountBundlesPaginated(
		requestParameters: GetAccountBundlesPaginatedRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<Array<Bundle>> {
		const response = await this.getAccountBundlesPaginatedRaw(requestParameters, initOverrides);
		return await response.value();
	}

	/**
	 * Retrieve an account by external key
	 */
	async getAccountByKeyRaw(
		requestParameters: GetAccountByKeyRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<Account>> {
		if (requestParameters.externalKey === null || requestParameters.externalKey === undefined) {
			throw new runtime.RequiredError(
				'externalKey',
				'Required parameter requestParameters.externalKey was null or undefined when calling getAccountByKey.'
			);
		}

		const queryParameters: any = {};

		if (requestParameters.externalKey !== undefined) {
			queryParameters['externalKey'] = requestParameters.externalKey;
		}

		if (requestParameters.accountWithBalance !== undefined) {
			queryParameters['accountWithBalance'] = requestParameters.accountWithBalance;
		}

		if (requestParameters.accountWithBalanceAndCBA !== undefined) {
			queryParameters['accountWithBalanceAndCBA'] = requestParameters.accountWithBalanceAndCBA;
		}

		if (requestParameters.audit !== undefined) {
			queryParameters['audit'] = requestParameters.audit;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiKey'] = this.configuration.apiKey('X-Killbill-ApiKey'); // Killbill Api Key authentication
		}

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiSecret'] = this.configuration.apiKey('X-Killbill-ApiSecret'); // Killbill Api Secret authentication
		}

		if (
			this.configuration &&
			(this.configuration.username !== undefined || this.configuration.password !== undefined)
		) {
			headerParameters['Authorization'] =
				'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
		}
		const response = await this.request(
			{
				path: `/1.0/kb/accounts`,
				method: 'GET',
				headers: headerParameters,
				query: queryParameters
			},
			initOverrides
		);

		return new runtime.JSONApiResponse(response, (jsonValue) => AccountFromJSON(jsonValue));
	}

	/**
	 * Retrieve an account by external key
	 */
	async getAccountByKey(
		requestParameters: GetAccountByKeyRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<Account> {
		const response = await this.getAccountByKeyRaw(requestParameters, initOverrides);
		return await response.value();
	}

	/**
	 * Retrieve account custom fields
	 */
	async getAccountCustomFieldsRaw(
		requestParameters: GetAccountCustomFieldsRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<Array<CustomField>>> {
		if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
			throw new runtime.RequiredError(
				'accountId',
				'Required parameter requestParameters.accountId was null or undefined when calling getAccountCustomFields.'
			);
		}

		const queryParameters: any = {};

		if (requestParameters.audit !== undefined) {
			queryParameters['audit'] = requestParameters.audit;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiKey'] = this.configuration.apiKey('X-Killbill-ApiKey'); // Killbill Api Key authentication
		}

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiSecret'] = this.configuration.apiKey('X-Killbill-ApiSecret'); // Killbill Api Secret authentication
		}

		if (
			this.configuration &&
			(this.configuration.username !== undefined || this.configuration.password !== undefined)
		) {
			headerParameters['Authorization'] =
				'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
		}
		const response = await this.request(
			{
				path: `/1.0/kb/accounts/{accountId}/customFields`.replace(
					`{${'accountId'}}`,
					encodeURIComponent(String(requestParameters.accountId))
				),
				method: 'GET',
				headers: headerParameters,
				query: queryParameters
			},
			initOverrides
		);

		return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(CustomFieldFromJSON));
	}

	/**
	 * Retrieve account custom fields
	 */
	async getAccountCustomFields(
		requestParameters: GetAccountCustomFieldsRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<Array<CustomField>> {
		const response = await this.getAccountCustomFieldsRaw(requestParameters, initOverrides);
		return await response.value();
	}

	/**
	 * Retrieve account email audit logs with history by id
	 */
	async getAccountEmailAuditLogsWithHistoryRaw(
		requestParameters: GetAccountEmailAuditLogsWithHistoryRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<Array<AuditLog>>> {
		if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
			throw new runtime.RequiredError(
				'accountId',
				'Required parameter requestParameters.accountId was null or undefined when calling getAccountEmailAuditLogsWithHistory.'
			);
		}

		if (
			requestParameters.accountEmailId === null ||
			requestParameters.accountEmailId === undefined
		) {
			throw new runtime.RequiredError(
				'accountEmailId',
				'Required parameter requestParameters.accountEmailId was null or undefined when calling getAccountEmailAuditLogsWithHistory.'
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiKey'] = this.configuration.apiKey('X-Killbill-ApiKey'); // Killbill Api Key authentication
		}

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiSecret'] = this.configuration.apiKey('X-Killbill-ApiSecret'); // Killbill Api Secret authentication
		}

		if (
			this.configuration &&
			(this.configuration.username !== undefined || this.configuration.password !== undefined)
		) {
			headerParameters['Authorization'] =
				'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
		}
		const response = await this.request(
			{
				path: `/1.0/kb/accounts/{accountId}/emails/{accountEmailId}/auditLogsWithHistory`
					.replace(`{${'accountId'}}`, encodeURIComponent(String(requestParameters.accountId)))
					.replace(
						`{${'accountEmailId'}}`,
						encodeURIComponent(String(requestParameters.accountEmailId))
					),
				method: 'GET',
				headers: headerParameters,
				query: queryParameters
			},
			initOverrides
		);

		return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(AuditLogFromJSON));
	}

	/**
	 * Retrieve account email audit logs with history by id
	 */
	async getAccountEmailAuditLogsWithHistory(
		requestParameters: GetAccountEmailAuditLogsWithHistoryRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<Array<AuditLog>> {
		const response = await this.getAccountEmailAuditLogsWithHistoryRaw(
			requestParameters,
			initOverrides
		);
		return await response.value();
	}

	/**
	 * Retrieve account tags
	 */
	async getAccountTagsRaw(
		requestParameters: GetAccountTagsRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<Array<Tag>>> {
		if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
			throw new runtime.RequiredError(
				'accountId',
				'Required parameter requestParameters.accountId was null or undefined when calling getAccountTags.'
			);
		}

		const queryParameters: any = {};

		if (requestParameters.includedDeleted !== undefined) {
			queryParameters['includedDeleted'] = requestParameters.includedDeleted;
		}

		if (requestParameters.audit !== undefined) {
			queryParameters['audit'] = requestParameters.audit;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiKey'] = this.configuration.apiKey('X-Killbill-ApiKey'); // Killbill Api Key authentication
		}

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiSecret'] = this.configuration.apiKey('X-Killbill-ApiSecret'); // Killbill Api Secret authentication
		}

		if (
			this.configuration &&
			(this.configuration.username !== undefined || this.configuration.password !== undefined)
		) {
			headerParameters['Authorization'] =
				'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
		}
		const response = await this.request(
			{
				path: `/1.0/kb/accounts/{accountId}/tags`.replace(
					`{${'accountId'}}`,
					encodeURIComponent(String(requestParameters.accountId))
				),
				method: 'GET',
				headers: headerParameters,
				query: queryParameters
			},
			initOverrides
		);

		return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TagFromJSON));
	}

	/**
	 * Retrieve account tags
	 */
	async getAccountTags(
		requestParameters: GetAccountTagsRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<Array<Tag>> {
		const response = await this.getAccountTagsRaw(requestParameters, initOverrides);
		return await response.value();
	}

	/**
	 * Retrieve account timeline
	 */
	async getAccountTimelineRaw(
		requestParameters: GetAccountTimelineRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<AccountTimeline>> {
		if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
			throw new runtime.RequiredError(
				'accountId',
				'Required parameter requestParameters.accountId was null or undefined when calling getAccountTimeline.'
			);
		}

		const queryParameters: any = {};

		if (requestParameters.parallel !== undefined) {
			queryParameters['parallel'] = requestParameters.parallel;
		}

		if (requestParameters.audit !== undefined) {
			queryParameters['audit'] = requestParameters.audit;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiKey'] = this.configuration.apiKey('X-Killbill-ApiKey'); // Killbill Api Key authentication
		}

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiSecret'] = this.configuration.apiKey('X-Killbill-ApiSecret'); // Killbill Api Secret authentication
		}

		if (
			this.configuration &&
			(this.configuration.username !== undefined || this.configuration.password !== undefined)
		) {
			headerParameters['Authorization'] =
				'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
		}
		const response = await this.request(
			{
				path: `/1.0/kb/accounts/{accountId}/timeline`.replace(
					`{${'accountId'}}`,
					encodeURIComponent(String(requestParameters.accountId))
				),
				method: 'GET',
				headers: headerParameters,
				query: queryParameters
			},
			initOverrides
		);

		return new runtime.JSONApiResponse(response, (jsonValue) => AccountTimelineFromJSON(jsonValue));
	}

	/**
	 * Retrieve account timeline
	 */
	async getAccountTimeline(
		requestParameters: GetAccountTimelineRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<AccountTimeline> {
		const response = await this.getAccountTimelineRaw(requestParameters, initOverrides);
		return await response.value();
	}

	/**
	 * List accounts
	 */
	async getAccountsRaw(
		requestParameters: GetAccountsRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<Array<Account>>> {
		const queryParameters: any = {};

		if (requestParameters.offset !== undefined) {
			queryParameters['offset'] = requestParameters.offset;
		}

		if (requestParameters.limit !== undefined) {
			queryParameters['limit'] = requestParameters.limit;
		}

		if (requestParameters.accountWithBalance !== undefined) {
			queryParameters['accountWithBalance'] = requestParameters.accountWithBalance;
		}

		if (requestParameters.accountWithBalanceAndCBA !== undefined) {
			queryParameters['accountWithBalanceAndCBA'] = requestParameters.accountWithBalanceAndCBA;
		}

		if (requestParameters.audit !== undefined) {
			queryParameters['audit'] = requestParameters.audit;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiKey'] = this.configuration.apiKey('X-Killbill-ApiKey'); // Killbill Api Key authentication
		}

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiSecret'] = this.configuration.apiKey('X-Killbill-ApiSecret'); // Killbill Api Secret authentication
		}

		if (
			this.configuration &&
			(this.configuration.username !== undefined || this.configuration.password !== undefined)
		) {
			headerParameters['Authorization'] =
				'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
		}
		const response = await this.request(
			{
				path: `/1.0/kb/accounts/pagination`,
				method: 'GET',
				headers: headerParameters,
				query: queryParameters
			},
			initOverrides
		);

		return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(AccountFromJSON));
	}

	/**
	 * List accounts
	 */
	async getAccounts(
		requestParameters: GetAccountsRequest = {},
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<Array<Account>> {
		const response = await this.getAccountsRaw(requestParameters, initOverrides);
		return await response.value();
	}

	/**
	 * Retrieve account customFields
	 */
	async getAllCustomFieldsRaw(
		requestParameters: GetAllCustomFieldsRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<Array<CustomField>>> {
		if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
			throw new runtime.RequiredError(
				'accountId',
				'Required parameter requestParameters.accountId was null or undefined when calling getAllCustomFields.'
			);
		}

		const queryParameters: any = {};

		if (requestParameters.objectType !== undefined) {
			queryParameters['objectType'] = requestParameters.objectType;
		}

		if (requestParameters.audit !== undefined) {
			queryParameters['audit'] = requestParameters.audit;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiKey'] = this.configuration.apiKey('X-Killbill-ApiKey'); // Killbill Api Key authentication
		}

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiSecret'] = this.configuration.apiKey('X-Killbill-ApiSecret'); // Killbill Api Secret authentication
		}

		if (
			this.configuration &&
			(this.configuration.username !== undefined || this.configuration.password !== undefined)
		) {
			headerParameters['Authorization'] =
				'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
		}
		const response = await this.request(
			{
				path: `/1.0/kb/accounts/{accountId}/allCustomFields`.replace(
					`{${'accountId'}}`,
					encodeURIComponent(String(requestParameters.accountId))
				),
				method: 'GET',
				headers: headerParameters,
				query: queryParameters
			},
			initOverrides
		);

		return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(CustomFieldFromJSON));
	}

	/**
	 * Retrieve account customFields
	 */
	async getAllCustomFields(
		requestParameters: GetAllCustomFieldsRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<Array<CustomField>> {
		const response = await this.getAllCustomFieldsRaw(requestParameters, initOverrides);
		return await response.value();
	}

	/**
	 * Retrieve account tags
	 */
	async getAllTagsRaw(
		requestParameters: GetAllTagsRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<Array<Tag>>> {
		if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
			throw new runtime.RequiredError(
				'accountId',
				'Required parameter requestParameters.accountId was null or undefined when calling getAllTags.'
			);
		}

		const queryParameters: any = {};

		if (requestParameters.objectType !== undefined) {
			queryParameters['objectType'] = requestParameters.objectType;
		}

		if (requestParameters.includedDeleted !== undefined) {
			queryParameters['includedDeleted'] = requestParameters.includedDeleted;
		}

		if (requestParameters.audit !== undefined) {
			queryParameters['audit'] = requestParameters.audit;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiKey'] = this.configuration.apiKey('X-Killbill-ApiKey'); // Killbill Api Key authentication
		}

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiSecret'] = this.configuration.apiKey('X-Killbill-ApiSecret'); // Killbill Api Secret authentication
		}

		if (
			this.configuration &&
			(this.configuration.username !== undefined || this.configuration.password !== undefined)
		) {
			headerParameters['Authorization'] =
				'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
		}
		const response = await this.request(
			{
				path: `/1.0/kb/accounts/{accountId}/allTags`.replace(
					`{${'accountId'}}`,
					encodeURIComponent(String(requestParameters.accountId))
				),
				method: 'GET',
				headers: headerParameters,
				query: queryParameters
			},
			initOverrides
		);

		return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TagFromJSON));
	}

	/**
	 * Retrieve account tags
	 */
	async getAllTags(
		requestParameters: GetAllTagsRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<Array<Tag>> {
		const response = await this.getAllTagsRaw(requestParameters, initOverrides);
		return await response.value();
	}

	/**
	 * Retrieve blocking state audit logs with history by id
	 */
	async getBlockingStateAuditLogsWithHistoryRaw(
		requestParameters: GetBlockingStateAuditLogsWithHistoryRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<Array<AuditLog>>> {
		if (requestParameters.blockingId === null || requestParameters.blockingId === undefined) {
			throw new runtime.RequiredError(
				'blockingId',
				'Required parameter requestParameters.blockingId was null or undefined when calling getBlockingStateAuditLogsWithHistory.'
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiKey'] = this.configuration.apiKey('X-Killbill-ApiKey'); // Killbill Api Key authentication
		}

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiSecret'] = this.configuration.apiKey('X-Killbill-ApiSecret'); // Killbill Api Secret authentication
		}

		if (
			this.configuration &&
			(this.configuration.username !== undefined || this.configuration.password !== undefined)
		) {
			headerParameters['Authorization'] =
				'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
		}
		const response = await this.request(
			{
				path: `/1.0/kb/accounts/block/{blockingId}/auditLogsWithHistory`.replace(
					`{${'blockingId'}}`,
					encodeURIComponent(String(requestParameters.blockingId))
				),
				method: 'GET',
				headers: headerParameters,
				query: queryParameters
			},
			initOverrides
		);

		return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(AuditLogFromJSON));
	}

	/**
	 * Retrieve blocking state audit logs with history by id
	 */
	async getBlockingStateAuditLogsWithHistory(
		requestParameters: GetBlockingStateAuditLogsWithHistoryRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<Array<AuditLog>> {
		const response = await this.getBlockingStateAuditLogsWithHistoryRaw(
			requestParameters,
			initOverrides
		);
		return await response.value();
	}

	/**
	 * Retrieve blocking states for account
	 */
	async getBlockingStatesRaw(
		requestParameters: GetBlockingStatesRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<Array<BlockingState>>> {
		if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
			throw new runtime.RequiredError(
				'accountId',
				'Required parameter requestParameters.accountId was null or undefined when calling getBlockingStates.'
			);
		}

		const queryParameters: any = {};

		if (requestParameters.blockingStateTypes) {
			queryParameters['blockingStateTypes'] = requestParameters.blockingStateTypes;
		}

		if (requestParameters.blockingStateSvcs) {
			queryParameters['blockingStateSvcs'] = requestParameters.blockingStateSvcs;
		}

		if (requestParameters.audit !== undefined) {
			queryParameters['audit'] = requestParameters.audit;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiKey'] = this.configuration.apiKey('X-Killbill-ApiKey'); // Killbill Api Key authentication
		}

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiSecret'] = this.configuration.apiKey('X-Killbill-ApiSecret'); // Killbill Api Secret authentication
		}

		if (
			this.configuration &&
			(this.configuration.username !== undefined || this.configuration.password !== undefined)
		) {
			headerParameters['Authorization'] =
				'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
		}
		const response = await this.request(
			{
				path: `/1.0/kb/accounts/{accountId}/block`.replace(
					`{${'accountId'}}`,
					encodeURIComponent(String(requestParameters.accountId))
				),
				method: 'GET',
				headers: headerParameters,
				query: queryParameters
			},
			initOverrides
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			jsonValue.map(BlockingStateFromJSON)
		);
	}

	/**
	 * Retrieve blocking states for account
	 */
	async getBlockingStates(
		requestParameters: GetBlockingStatesRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<Array<BlockingState>> {
		const response = await this.getBlockingStatesRaw(requestParameters, initOverrides);
		return await response.value();
	}

	/**
	 * List children accounts
	 */
	async getChildrenAccountsRaw(
		requestParameters: GetChildrenAccountsRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<Array<Account>>> {
		if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
			throw new runtime.RequiredError(
				'accountId',
				'Required parameter requestParameters.accountId was null or undefined when calling getChildrenAccounts.'
			);
		}

		const queryParameters: any = {};

		if (requestParameters.accountWithBalance !== undefined) {
			queryParameters['accountWithBalance'] = requestParameters.accountWithBalance;
		}

		if (requestParameters.accountWithBalanceAndCBA !== undefined) {
			queryParameters['accountWithBalanceAndCBA'] = requestParameters.accountWithBalanceAndCBA;
		}

		if (requestParameters.audit !== undefined) {
			queryParameters['audit'] = requestParameters.audit;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiKey'] = this.configuration.apiKey('X-Killbill-ApiKey'); // Killbill Api Key authentication
		}

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiSecret'] = this.configuration.apiKey('X-Killbill-ApiSecret'); // Killbill Api Secret authentication
		}

		if (
			this.configuration &&
			(this.configuration.username !== undefined || this.configuration.password !== undefined)
		) {
			headerParameters['Authorization'] =
				'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
		}
		const response = await this.request(
			{
				path: `/1.0/kb/accounts/{accountId}/children`.replace(
					`{${'accountId'}}`,
					encodeURIComponent(String(requestParameters.accountId))
				),
				method: 'GET',
				headers: headerParameters,
				query: queryParameters
			},
			initOverrides
		);

		return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(AccountFromJSON));
	}

	/**
	 * List children accounts
	 */
	async getChildrenAccounts(
		requestParameters: GetChildrenAccountsRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<Array<Account>> {
		const response = await this.getChildrenAccountsRaw(requestParameters, initOverrides);
		return await response.value();
	}

	/**
	 * Retrieve an account emails
	 */
	async getEmailsRaw(
		requestParameters: GetEmailsRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<Array<AccountEmail>>> {
		if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
			throw new runtime.RequiredError(
				'accountId',
				'Required parameter requestParameters.accountId was null or undefined when calling getEmails.'
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiKey'] = this.configuration.apiKey('X-Killbill-ApiKey'); // Killbill Api Key authentication
		}

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiSecret'] = this.configuration.apiKey('X-Killbill-ApiSecret'); // Killbill Api Secret authentication
		}

		if (
			this.configuration &&
			(this.configuration.username !== undefined || this.configuration.password !== undefined)
		) {
			headerParameters['Authorization'] =
				'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
		}
		const response = await this.request(
			{
				path: `/1.0/kb/accounts/{accountId}/emails`.replace(
					`{${'accountId'}}`,
					encodeURIComponent(String(requestParameters.accountId))
				),
				method: 'GET',
				headers: headerParameters,
				query: queryParameters
			},
			initOverrides
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			jsonValue.map(AccountEmailFromJSON)
		);
	}

	/**
	 * Retrieve an account emails
	 */
	async getEmails(
		requestParameters: GetEmailsRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<Array<AccountEmail>> {
		const response = await this.getEmailsRaw(requestParameters, initOverrides);
		return await response.value();
	}

	/**
	 * Retrieve account invoice payments
	 */
	async getInvoicePaymentsRaw(
		requestParameters: GetInvoicePaymentsRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<Array<InvoicePayment>>> {
		if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
			throw new runtime.RequiredError(
				'accountId',
				'Required parameter requestParameters.accountId was null or undefined when calling getInvoicePayments.'
			);
		}

		const queryParameters: any = {};

		if (requestParameters.withPluginInfo !== undefined) {
			queryParameters['withPluginInfo'] = requestParameters.withPluginInfo;
		}

		if (requestParameters.withAttempts !== undefined) {
			queryParameters['withAttempts'] = requestParameters.withAttempts;
		}

		if (requestParameters.pluginProperty) {
			queryParameters['pluginProperty'] = requestParameters.pluginProperty;
		}

		if (requestParameters.audit !== undefined) {
			queryParameters['audit'] = requestParameters.audit;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiKey'] = this.configuration.apiKey('X-Killbill-ApiKey'); // Killbill Api Key authentication
		}

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiSecret'] = this.configuration.apiKey('X-Killbill-ApiSecret'); // Killbill Api Secret authentication
		}

		if (
			this.configuration &&
			(this.configuration.username !== undefined || this.configuration.password !== undefined)
		) {
			headerParameters['Authorization'] =
				'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
		}
		const response = await this.request(
			{
				path: `/1.0/kb/accounts/{accountId}/invoicePayments`.replace(
					`{${'accountId'}}`,
					encodeURIComponent(String(requestParameters.accountId))
				),
				method: 'GET',
				headers: headerParameters,
				query: queryParameters
			},
			initOverrides
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			jsonValue.map(InvoicePaymentFromJSON)
		);
	}

	/**
	 * Retrieve account invoice payments
	 */
	async getInvoicePayments(
		requestParameters: GetInvoicePaymentsRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<Array<InvoicePayment>> {
		const response = await this.getInvoicePaymentsRaw(requestParameters, initOverrides);
		return await response.value();
	}

	/**
	 * Retrieve account invoices
	 */
	async getInvoicesForAccountRaw(
		requestParameters: GetInvoicesForAccountRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<Array<Invoice>>> {
		if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
			throw new runtime.RequiredError(
				'accountId',
				'Required parameter requestParameters.accountId was null or undefined when calling getInvoicesForAccount.'
			);
		}

		const queryParameters: any = {};

		if (requestParameters.startDate !== undefined) {
			queryParameters['startDate'] = (requestParameters.startDate as any)
				.toISOString()
				.substr(0, 10);
		}

		if (requestParameters.endDate !== undefined) {
			queryParameters['endDate'] = (requestParameters.endDate as any).toISOString().substr(0, 10);
		}

		if (requestParameters.withMigrationInvoices !== undefined) {
			queryParameters['withMigrationInvoices'] = requestParameters.withMigrationInvoices;
		}

		if (requestParameters.unpaidInvoicesOnly !== undefined) {
			queryParameters['unpaidInvoicesOnly'] = requestParameters.unpaidInvoicesOnly;
		}

		if (requestParameters.includeVoidedInvoices !== undefined) {
			queryParameters['includeVoidedInvoices'] = requestParameters.includeVoidedInvoices;
		}

		if (requestParameters.includeInvoiceComponents !== undefined) {
			queryParameters['includeInvoiceComponents'] = requestParameters.includeInvoiceComponents;
		}

		if (requestParameters.invoicesFilter !== undefined) {
			queryParameters['invoicesFilter'] = requestParameters.invoicesFilter;
		}

		if (requestParameters.audit !== undefined) {
			queryParameters['audit'] = requestParameters.audit;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiKey'] = this.configuration.apiKey('X-Killbill-ApiKey'); // Killbill Api Key authentication
		}

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiSecret'] = this.configuration.apiKey('X-Killbill-ApiSecret'); // Killbill Api Secret authentication
		}

		if (
			this.configuration &&
			(this.configuration.username !== undefined || this.configuration.password !== undefined)
		) {
			headerParameters['Authorization'] =
				'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
		}
		const response = await this.request(
			{
				path: `/1.0/kb/accounts/{accountId}/invoices`.replace(
					`{${'accountId'}}`,
					encodeURIComponent(String(requestParameters.accountId))
				),
				method: 'GET',
				headers: headerParameters,
				query: queryParameters
			},
			initOverrides
		);

		return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(InvoiceFromJSON));
	}

	/**
	 * Retrieve account invoices
	 */
	async getInvoicesForAccount(
		requestParameters: GetInvoicesForAccountRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<Array<Invoice>> {
		const response = await this.getInvoicesForAccountRaw(requestParameters, initOverrides);
		return await response.value();
	}

	/**
	 * Retrieve paginated invoices for account
	 */
	async getInvoicesForAccountPaginatedRaw(
		requestParameters: GetInvoicesForAccountPaginatedRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<Array<Invoice>>> {
		if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
			throw new runtime.RequiredError(
				'accountId',
				'Required parameter requestParameters.accountId was null or undefined when calling getInvoicesForAccountPaginated.'
			);
		}

		const queryParameters: any = {};

		if (requestParameters.offset !== undefined) {
			queryParameters['offset'] = requestParameters.offset;
		}

		if (requestParameters.limit !== undefined) {
			queryParameters['limit'] = requestParameters.limit;
		}

		if (requestParameters.audit !== undefined) {
			queryParameters['audit'] = requestParameters.audit;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiKey'] = this.configuration.apiKey('X-Killbill-ApiKey'); // Killbill Api Key authentication
		}

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiSecret'] = this.configuration.apiKey('X-Killbill-ApiSecret'); // Killbill Api Secret authentication
		}

		if (
			this.configuration &&
			(this.configuration.username !== undefined || this.configuration.password !== undefined)
		) {
			headerParameters['Authorization'] =
				'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
		}
		const response = await this.request(
			{
				path: `/1.0/kb/accounts/{accountId}/invoices/pagination`.replace(
					`{${'accountId'}}`,
					encodeURIComponent(String(requestParameters.accountId))
				),
				method: 'GET',
				headers: headerParameters,
				query: queryParameters
			},
			initOverrides
		);

		return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(InvoiceFromJSON));
	}

	/**
	 * Retrieve paginated invoices for account
	 */
	async getInvoicesForAccountPaginated(
		requestParameters: GetInvoicesForAccountPaginatedRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<Array<Invoice>> {
		const response = await this.getInvoicesForAccountPaginatedRaw(requestParameters, initOverrides);
		return await response.value();
	}

	/**
	 * Retrieve overdue state for account
	 */
	async getOverdueAccountRaw(
		requestParameters: GetOverdueAccountRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<OverdueState>> {
		if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
			throw new runtime.RequiredError(
				'accountId',
				'Required parameter requestParameters.accountId was null or undefined when calling getOverdueAccount.'
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiKey'] = this.configuration.apiKey('X-Killbill-ApiKey'); // Killbill Api Key authentication
		}

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiSecret'] = this.configuration.apiKey('X-Killbill-ApiSecret'); // Killbill Api Secret authentication
		}

		if (
			this.configuration &&
			(this.configuration.username !== undefined || this.configuration.password !== undefined)
		) {
			headerParameters['Authorization'] =
				'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
		}
		const response = await this.request(
			{
				path: `/1.0/kb/accounts/{accountId}/overdue`.replace(
					`{${'accountId'}}`,
					encodeURIComponent(String(requestParameters.accountId))
				),
				method: 'GET',
				headers: headerParameters,
				query: queryParameters
			},
			initOverrides
		);

		return new runtime.JSONApiResponse(response, (jsonValue) => OverdueStateFromJSON(jsonValue));
	}

	/**
	 * Retrieve overdue state for account
	 */
	async getOverdueAccount(
		requestParameters: GetOverdueAccountRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<OverdueState> {
		const response = await this.getOverdueAccountRaw(requestParameters, initOverrides);
		return await response.value();
	}

	/**
	 * Retrieve account payment methods
	 */
	async getPaymentMethodsForAccountRaw(
		requestParameters: GetPaymentMethodsForAccountRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<Array<PaymentMethod>>> {
		if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
			throw new runtime.RequiredError(
				'accountId',
				'Required parameter requestParameters.accountId was null or undefined when calling getPaymentMethodsForAccount.'
			);
		}

		const queryParameters: any = {};

		if (requestParameters.withPluginInfo !== undefined) {
			queryParameters['withPluginInfo'] = requestParameters.withPluginInfo;
		}

		if (requestParameters.includedDeleted !== undefined) {
			queryParameters['includedDeleted'] = requestParameters.includedDeleted;
		}

		if (requestParameters.pluginProperty) {
			queryParameters['pluginProperty'] = requestParameters.pluginProperty;
		}

		if (requestParameters.audit !== undefined) {
			queryParameters['audit'] = requestParameters.audit;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiKey'] = this.configuration.apiKey('X-Killbill-ApiKey'); // Killbill Api Key authentication
		}

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiSecret'] = this.configuration.apiKey('X-Killbill-ApiSecret'); // Killbill Api Secret authentication
		}

		if (
			this.configuration &&
			(this.configuration.username !== undefined || this.configuration.password !== undefined)
		) {
			headerParameters['Authorization'] =
				'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
		}
		const response = await this.request(
			{
				path: `/1.0/kb/accounts/{accountId}/paymentMethods`.replace(
					`{${'accountId'}}`,
					encodeURIComponent(String(requestParameters.accountId))
				),
				method: 'GET',
				headers: headerParameters,
				query: queryParameters
			},
			initOverrides
		);

		return new runtime.JSONApiResponse(response, (jsonValue) =>
			jsonValue.map(PaymentMethodFromJSON)
		);
	}

	/**
	 * Retrieve account payment methods
	 */
	async getPaymentMethodsForAccount(
		requestParameters: GetPaymentMethodsForAccountRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<Array<PaymentMethod>> {
		const response = await this.getPaymentMethodsForAccountRaw(requestParameters, initOverrides);
		return await response.value();
	}

	/**
	 * Retrieve account payments
	 */
	async getPaymentsForAccountRaw(
		requestParameters: GetPaymentsForAccountRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<Array<Payment>>> {
		if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
			throw new runtime.RequiredError(
				'accountId',
				'Required parameter requestParameters.accountId was null or undefined when calling getPaymentsForAccount.'
			);
		}

		const queryParameters: any = {};

		if (requestParameters.withAttempts !== undefined) {
			queryParameters['withAttempts'] = requestParameters.withAttempts;
		}

		if (requestParameters.withPluginInfo !== undefined) {
			queryParameters['withPluginInfo'] = requestParameters.withPluginInfo;
		}

		if (requestParameters.pluginProperty) {
			queryParameters['pluginProperty'] = requestParameters.pluginProperty;
		}

		if (requestParameters.audit !== undefined) {
			queryParameters['audit'] = requestParameters.audit;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiKey'] = this.configuration.apiKey('X-Killbill-ApiKey'); // Killbill Api Key authentication
		}

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiSecret'] = this.configuration.apiKey('X-Killbill-ApiSecret'); // Killbill Api Secret authentication
		}

		if (
			this.configuration &&
			(this.configuration.username !== undefined || this.configuration.password !== undefined)
		) {
			headerParameters['Authorization'] =
				'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
		}
		const response = await this.request(
			{
				path: `/1.0/kb/accounts/{accountId}/payments`.replace(
					`{${'accountId'}}`,
					encodeURIComponent(String(requestParameters.accountId))
				),
				method: 'GET',
				headers: headerParameters,
				query: queryParameters
			},
			initOverrides
		);

		return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(PaymentFromJSON));
	}

	/**
	 * Retrieve account payments
	 */
	async getPaymentsForAccount(
		requestParameters: GetPaymentsForAccountRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<Array<Payment>> {
		const response = await this.getPaymentsForAccountRaw(requestParameters, initOverrides);
		return await response.value();
	}

	/**
	 * Modify custom fields to account
	 */
	async modifyAccountCustomFieldsRaw(
		requestParameters: ModifyAccountCustomFieldsRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<void>> {
		if (requestParameters.body === null || requestParameters.body === undefined) {
			throw new runtime.RequiredError(
				'body',
				'Required parameter requestParameters.body was null or undefined when calling modifyAccountCustomFields.'
			);
		}

		if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
			throw new runtime.RequiredError(
				'accountId',
				'Required parameter requestParameters.accountId was null or undefined when calling modifyAccountCustomFields.'
			);
		}

		if (
			requestParameters.xKillbillCreatedBy === null ||
			requestParameters.xKillbillCreatedBy === undefined
		) {
			throw new runtime.RequiredError(
				'xKillbillCreatedBy',
				'Required parameter requestParameters.xKillbillCreatedBy was null or undefined when calling modifyAccountCustomFields.'
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters['Content-Type'] = 'application/json';

		if (
			requestParameters.xKillbillCreatedBy !== undefined &&
			requestParameters.xKillbillCreatedBy !== null
		) {
			headerParameters['X-Killbill-CreatedBy'] = String(requestParameters.xKillbillCreatedBy);
		}

		if (
			requestParameters.xKillbillReason !== undefined &&
			requestParameters.xKillbillReason !== null
		) {
			headerParameters['X-Killbill-Reason'] = String(requestParameters.xKillbillReason);
		}

		if (
			requestParameters.xKillbillComment !== undefined &&
			requestParameters.xKillbillComment !== null
		) {
			headerParameters['X-Killbill-Comment'] = String(requestParameters.xKillbillComment);
		}

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiKey'] = this.configuration.apiKey('X-Killbill-ApiKey'); // Killbill Api Key authentication
		}

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiSecret'] = this.configuration.apiKey('X-Killbill-ApiSecret'); // Killbill Api Secret authentication
		}

		if (
			this.configuration &&
			(this.configuration.username !== undefined || this.configuration.password !== undefined)
		) {
			headerParameters['Authorization'] =
				'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
		}
		const response = await this.request(
			{
				path: `/1.0/kb/accounts/{accountId}/customFields`.replace(
					`{${'accountId'}}`,
					encodeURIComponent(String(requestParameters.accountId))
				),
				method: 'PUT',
				headers: headerParameters,
				query: queryParameters,
				body: requestParameters.body.map(CustomFieldToJSON)
			},
			initOverrides
		);

		return new runtime.VoidApiResponse(response);
	}

	/**
	 * Modify custom fields to account
	 */
	async modifyAccountCustomFields(
		requestParameters: ModifyAccountCustomFieldsRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<void> {
		await this.modifyAccountCustomFieldsRaw(requestParameters, initOverrides);
	}

	/**
	 * Trigger a payment for all unpaid invoices
	 */
	async payAllInvoicesRaw(
		requestParameters: PayAllInvoicesRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<Array<Invoice>>> {
		if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
			throw new runtime.RequiredError(
				'accountId',
				'Required parameter requestParameters.accountId was null or undefined when calling payAllInvoices.'
			);
		}

		if (
			requestParameters.xKillbillCreatedBy === null ||
			requestParameters.xKillbillCreatedBy === undefined
		) {
			throw new runtime.RequiredError(
				'xKillbillCreatedBy',
				'Required parameter requestParameters.xKillbillCreatedBy was null or undefined when calling payAllInvoices.'
			);
		}

		const queryParameters: any = {};

		if (requestParameters.paymentMethodId !== undefined) {
			queryParameters['paymentMethodId'] = requestParameters.paymentMethodId;
		}

		if (requestParameters.externalPayment !== undefined) {
			queryParameters['externalPayment'] = requestParameters.externalPayment;
		}

		if (requestParameters.paymentAmount !== undefined) {
			queryParameters['paymentAmount'] = requestParameters.paymentAmount;
		}

		if (requestParameters.targetDate !== undefined) {
			queryParameters['targetDate'] = (requestParameters.targetDate as any)
				.toISOString()
				.substr(0, 10);
		}

		if (requestParameters.pluginProperty) {
			queryParameters['pluginProperty'] = requestParameters.pluginProperty;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (
			requestParameters.xKillbillCreatedBy !== undefined &&
			requestParameters.xKillbillCreatedBy !== null
		) {
			headerParameters['X-Killbill-CreatedBy'] = String(requestParameters.xKillbillCreatedBy);
		}

		if (
			requestParameters.xKillbillReason !== undefined &&
			requestParameters.xKillbillReason !== null
		) {
			headerParameters['X-Killbill-Reason'] = String(requestParameters.xKillbillReason);
		}

		if (
			requestParameters.xKillbillComment !== undefined &&
			requestParameters.xKillbillComment !== null
		) {
			headerParameters['X-Killbill-Comment'] = String(requestParameters.xKillbillComment);
		}

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiKey'] = this.configuration.apiKey('X-Killbill-ApiKey'); // Killbill Api Key authentication
		}

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiSecret'] = this.configuration.apiKey('X-Killbill-ApiSecret'); // Killbill Api Secret authentication
		}

		if (
			this.configuration &&
			(this.configuration.username !== undefined || this.configuration.password !== undefined)
		) {
			headerParameters['Authorization'] =
				'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
		}
		const response = await this.request(
			{
				path: `/1.0/kb/accounts/{accountId}/invoicePayments`.replace(
					`{${'accountId'}}`,
					encodeURIComponent(String(requestParameters.accountId))
				),
				method: 'POST',
				headers: headerParameters,
				query: queryParameters
			},
			initOverrides
		);

		return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(InvoiceFromJSON));
	}

	/**
	 * Trigger a payment for all unpaid invoices
	 */
	async payAllInvoices(
		requestParameters: PayAllInvoicesRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<Array<Invoice>> {
		const response = await this.payAllInvoicesRaw(requestParameters, initOverrides);
		return await response.value();
	}

	/**
	 * Trigger a payment (authorization, purchase or credit)
	 */
	async processPaymentRaw(
		requestParameters: ProcessPaymentRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<Payment>> {
		if (requestParameters.body === null || requestParameters.body === undefined) {
			throw new runtime.RequiredError(
				'body',
				'Required parameter requestParameters.body was null or undefined when calling processPayment.'
			);
		}

		if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
			throw new runtime.RequiredError(
				'accountId',
				'Required parameter requestParameters.accountId was null or undefined when calling processPayment.'
			);
		}

		if (
			requestParameters.xKillbillCreatedBy === null ||
			requestParameters.xKillbillCreatedBy === undefined
		) {
			throw new runtime.RequiredError(
				'xKillbillCreatedBy',
				'Required parameter requestParameters.xKillbillCreatedBy was null or undefined when calling processPayment.'
			);
		}

		const queryParameters: any = {};

		if (requestParameters.paymentMethodId !== undefined) {
			queryParameters['paymentMethodId'] = requestParameters.paymentMethodId;
		}

		if (requestParameters.controlPluginName) {
			queryParameters['controlPluginName'] = requestParameters.controlPluginName;
		}

		if (requestParameters.pluginProperty) {
			queryParameters['pluginProperty'] = requestParameters.pluginProperty;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters['Content-Type'] = 'application/json';

		if (
			requestParameters.xKillbillCreatedBy !== undefined &&
			requestParameters.xKillbillCreatedBy !== null
		) {
			headerParameters['X-Killbill-CreatedBy'] = String(requestParameters.xKillbillCreatedBy);
		}

		if (
			requestParameters.xKillbillReason !== undefined &&
			requestParameters.xKillbillReason !== null
		) {
			headerParameters['X-Killbill-Reason'] = String(requestParameters.xKillbillReason);
		}

		if (
			requestParameters.xKillbillComment !== undefined &&
			requestParameters.xKillbillComment !== null
		) {
			headerParameters['X-Killbill-Comment'] = String(requestParameters.xKillbillComment);
		}

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiKey'] = this.configuration.apiKey('X-Killbill-ApiKey'); // Killbill Api Key authentication
		}

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiSecret'] = this.configuration.apiKey('X-Killbill-ApiSecret'); // Killbill Api Secret authentication
		}

		if (
			this.configuration &&
			(this.configuration.username !== undefined || this.configuration.password !== undefined)
		) {
			headerParameters['Authorization'] =
				'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
		}
		const response = await this.request(
			{
				path: `/1.0/kb/accounts/{accountId}/payments`.replace(
					`{${'accountId'}}`,
					encodeURIComponent(String(requestParameters.accountId))
				),
				method: 'POST',
				headers: headerParameters,
				query: queryParameters,
				body: PaymentTransactionToJSON(requestParameters.body)
			},
			initOverrides
		);

		return new runtime.JSONApiResponse(response, (jsonValue) => PaymentFromJSON(jsonValue));
	}

	/**
	 * Trigger a payment (authorization, purchase or credit)
	 */
	async processPayment(
		requestParameters: ProcessPaymentRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<Payment> {
		const response = await this.processPaymentRaw(requestParameters, initOverrides);
		return await response.value();
	}

	/**
	 * Trigger a payment using the account external key (authorization, purchase or credit)
	 */
	async processPaymentByExternalKeyRaw(
		requestParameters: ProcessPaymentByExternalKeyRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<Payment>> {
		if (requestParameters.body === null || requestParameters.body === undefined) {
			throw new runtime.RequiredError(
				'body',
				'Required parameter requestParameters.body was null or undefined when calling processPaymentByExternalKey.'
			);
		}

		if (requestParameters.externalKey === null || requestParameters.externalKey === undefined) {
			throw new runtime.RequiredError(
				'externalKey',
				'Required parameter requestParameters.externalKey was null or undefined when calling processPaymentByExternalKey.'
			);
		}

		if (
			requestParameters.xKillbillCreatedBy === null ||
			requestParameters.xKillbillCreatedBy === undefined
		) {
			throw new runtime.RequiredError(
				'xKillbillCreatedBy',
				'Required parameter requestParameters.xKillbillCreatedBy was null or undefined when calling processPaymentByExternalKey.'
			);
		}

		const queryParameters: any = {};

		if (requestParameters.externalKey !== undefined) {
			queryParameters['externalKey'] = requestParameters.externalKey;
		}

		if (requestParameters.paymentMethodId !== undefined) {
			queryParameters['paymentMethodId'] = requestParameters.paymentMethodId;
		}

		if (requestParameters.controlPluginName) {
			queryParameters['controlPluginName'] = requestParameters.controlPluginName;
		}

		if (requestParameters.pluginProperty) {
			queryParameters['pluginProperty'] = requestParameters.pluginProperty;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters['Content-Type'] = 'application/json';

		if (
			requestParameters.xKillbillCreatedBy !== undefined &&
			requestParameters.xKillbillCreatedBy !== null
		) {
			headerParameters['X-Killbill-CreatedBy'] = String(requestParameters.xKillbillCreatedBy);
		}

		if (
			requestParameters.xKillbillReason !== undefined &&
			requestParameters.xKillbillReason !== null
		) {
			headerParameters['X-Killbill-Reason'] = String(requestParameters.xKillbillReason);
		}

		if (
			requestParameters.xKillbillComment !== undefined &&
			requestParameters.xKillbillComment !== null
		) {
			headerParameters['X-Killbill-Comment'] = String(requestParameters.xKillbillComment);
		}

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiKey'] = this.configuration.apiKey('X-Killbill-ApiKey'); // Killbill Api Key authentication
		}

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiSecret'] = this.configuration.apiKey('X-Killbill-ApiSecret'); // Killbill Api Secret authentication
		}

		if (
			this.configuration &&
			(this.configuration.username !== undefined || this.configuration.password !== undefined)
		) {
			headerParameters['Authorization'] =
				'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
		}
		const response = await this.request(
			{
				path: `/1.0/kb/accounts/payments`,
				method: 'POST',
				headers: headerParameters,
				query: queryParameters,
				body: PaymentTransactionToJSON(requestParameters.body)
			},
			initOverrides
		);

		return new runtime.JSONApiResponse(response, (jsonValue) => PaymentFromJSON(jsonValue));
	}

	/**
	 * Trigger a payment using the account external key (authorization, purchase or credit)
	 */
	async processPaymentByExternalKey(
		requestParameters: ProcessPaymentByExternalKeyRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<Payment> {
		const response = await this.processPaymentByExternalKeyRaw(requestParameters, initOverrides);
		return await response.value();
	}

	/**
	 * Rebalance account CBA
	 */
	async rebalanceExistingCBAOnAccountRaw(
		requestParameters: RebalanceExistingCBAOnAccountRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<void>> {
		if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
			throw new runtime.RequiredError(
				'accountId',
				'Required parameter requestParameters.accountId was null or undefined when calling rebalanceExistingCBAOnAccount.'
			);
		}

		if (
			requestParameters.xKillbillCreatedBy === null ||
			requestParameters.xKillbillCreatedBy === undefined
		) {
			throw new runtime.RequiredError(
				'xKillbillCreatedBy',
				'Required parameter requestParameters.xKillbillCreatedBy was null or undefined when calling rebalanceExistingCBAOnAccount.'
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (
			requestParameters.xKillbillCreatedBy !== undefined &&
			requestParameters.xKillbillCreatedBy !== null
		) {
			headerParameters['X-Killbill-CreatedBy'] = String(requestParameters.xKillbillCreatedBy);
		}

		if (
			requestParameters.xKillbillReason !== undefined &&
			requestParameters.xKillbillReason !== null
		) {
			headerParameters['X-Killbill-Reason'] = String(requestParameters.xKillbillReason);
		}

		if (
			requestParameters.xKillbillComment !== undefined &&
			requestParameters.xKillbillComment !== null
		) {
			headerParameters['X-Killbill-Comment'] = String(requestParameters.xKillbillComment);
		}

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiKey'] = this.configuration.apiKey('X-Killbill-ApiKey'); // Killbill Api Key authentication
		}

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiSecret'] = this.configuration.apiKey('X-Killbill-ApiSecret'); // Killbill Api Secret authentication
		}

		if (
			this.configuration &&
			(this.configuration.username !== undefined || this.configuration.password !== undefined)
		) {
			headerParameters['Authorization'] =
				'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
		}
		const response = await this.request(
			{
				path: `/1.0/kb/accounts/{accountId}/cbaRebalancing`.replace(
					`{${'accountId'}}`,
					encodeURIComponent(String(requestParameters.accountId))
				),
				method: 'PUT',
				headers: headerParameters,
				query: queryParameters
			},
			initOverrides
		);

		return new runtime.VoidApiResponse(response);
	}

	/**
	 * Rebalance account CBA
	 */
	async rebalanceExistingCBAOnAccount(
		requestParameters: RebalanceExistingCBAOnAccountRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<void> {
		await this.rebalanceExistingCBAOnAccountRaw(requestParameters, initOverrides);
	}

	/**
	 * Refresh account payment methods
	 */
	async refreshPaymentMethodsRaw(
		requestParameters: RefreshPaymentMethodsRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<void>> {
		if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
			throw new runtime.RequiredError(
				'accountId',
				'Required parameter requestParameters.accountId was null or undefined when calling refreshPaymentMethods.'
			);
		}

		if (
			requestParameters.xKillbillCreatedBy === null ||
			requestParameters.xKillbillCreatedBy === undefined
		) {
			throw new runtime.RequiredError(
				'xKillbillCreatedBy',
				'Required parameter requestParameters.xKillbillCreatedBy was null or undefined when calling refreshPaymentMethods.'
			);
		}

		const queryParameters: any = {};

		if (requestParameters.pluginName !== undefined) {
			queryParameters['pluginName'] = requestParameters.pluginName;
		}

		if (requestParameters.pluginProperty) {
			queryParameters['pluginProperty'] = requestParameters.pluginProperty;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (
			requestParameters.xKillbillCreatedBy !== undefined &&
			requestParameters.xKillbillCreatedBy !== null
		) {
			headerParameters['X-Killbill-CreatedBy'] = String(requestParameters.xKillbillCreatedBy);
		}

		if (
			requestParameters.xKillbillReason !== undefined &&
			requestParameters.xKillbillReason !== null
		) {
			headerParameters['X-Killbill-Reason'] = String(requestParameters.xKillbillReason);
		}

		if (
			requestParameters.xKillbillComment !== undefined &&
			requestParameters.xKillbillComment !== null
		) {
			headerParameters['X-Killbill-Comment'] = String(requestParameters.xKillbillComment);
		}

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiKey'] = this.configuration.apiKey('X-Killbill-ApiKey'); // Killbill Api Key authentication
		}

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiSecret'] = this.configuration.apiKey('X-Killbill-ApiSecret'); // Killbill Api Secret authentication
		}

		if (
			this.configuration &&
			(this.configuration.username !== undefined || this.configuration.password !== undefined)
		) {
			headerParameters['Authorization'] =
				'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
		}
		const response = await this.request(
			{
				path: `/1.0/kb/accounts/{accountId}/paymentMethods/refresh`.replace(
					`{${'accountId'}}`,
					encodeURIComponent(String(requestParameters.accountId))
				),
				method: 'PUT',
				headers: headerParameters,
				query: queryParameters
			},
			initOverrides
		);

		return new runtime.VoidApiResponse(response);
	}

	/**
	 * Refresh account payment methods
	 */
	async refreshPaymentMethods(
		requestParameters: RefreshPaymentMethodsRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<void> {
		await this.refreshPaymentMethodsRaw(requestParameters, initOverrides);
	}

	/**
	 * Delete email from account
	 */
	async removeEmailRaw(
		requestParameters: RemoveEmailRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<void>> {
		if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
			throw new runtime.RequiredError(
				'accountId',
				'Required parameter requestParameters.accountId was null or undefined when calling removeEmail.'
			);
		}

		if (requestParameters.email === null || requestParameters.email === undefined) {
			throw new runtime.RequiredError(
				'email',
				'Required parameter requestParameters.email was null or undefined when calling removeEmail.'
			);
		}

		if (
			requestParameters.xKillbillCreatedBy === null ||
			requestParameters.xKillbillCreatedBy === undefined
		) {
			throw new runtime.RequiredError(
				'xKillbillCreatedBy',
				'Required parameter requestParameters.xKillbillCreatedBy was null or undefined when calling removeEmail.'
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (
			requestParameters.xKillbillCreatedBy !== undefined &&
			requestParameters.xKillbillCreatedBy !== null
		) {
			headerParameters['X-Killbill-CreatedBy'] = String(requestParameters.xKillbillCreatedBy);
		}

		if (
			requestParameters.xKillbillReason !== undefined &&
			requestParameters.xKillbillReason !== null
		) {
			headerParameters['X-Killbill-Reason'] = String(requestParameters.xKillbillReason);
		}

		if (
			requestParameters.xKillbillComment !== undefined &&
			requestParameters.xKillbillComment !== null
		) {
			headerParameters['X-Killbill-Comment'] = String(requestParameters.xKillbillComment);
		}

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiKey'] = this.configuration.apiKey('X-Killbill-ApiKey'); // Killbill Api Key authentication
		}

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiSecret'] = this.configuration.apiKey('X-Killbill-ApiSecret'); // Killbill Api Secret authentication
		}

		if (
			this.configuration &&
			(this.configuration.username !== undefined || this.configuration.password !== undefined)
		) {
			headerParameters['Authorization'] =
				'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
		}
		const response = await this.request(
			{
				path: `/1.0/kb/accounts/{accountId}/emails/{email}`
					.replace(`{${'accountId'}}`, encodeURIComponent(String(requestParameters.accountId)))
					.replace(`{${'email'}}`, encodeURIComponent(String(requestParameters.email))),
				method: 'DELETE',
				headers: headerParameters,
				query: queryParameters
			},
			initOverrides
		);

		return new runtime.VoidApiResponse(response);
	}

	/**
	 * Delete email from account
	 */
	async removeEmail(
		requestParameters: RemoveEmailRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<void> {
		await this.removeEmailRaw(requestParameters, initOverrides);
	}

	/**
	 * Search accounts
	 */
	async searchAccountsRaw(
		requestParameters: SearchAccountsRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<Array<Account>>> {
		if (requestParameters.searchKey === null || requestParameters.searchKey === undefined) {
			throw new runtime.RequiredError(
				'searchKey',
				'Required parameter requestParameters.searchKey was null or undefined when calling searchAccounts.'
			);
		}

		const queryParameters: any = {};

		if (requestParameters.offset !== undefined) {
			queryParameters['offset'] = requestParameters.offset;
		}

		if (requestParameters.limit !== undefined) {
			queryParameters['limit'] = requestParameters.limit;
		}

		if (requestParameters.accountWithBalance !== undefined) {
			queryParameters['accountWithBalance'] = requestParameters.accountWithBalance;
		}

		if (requestParameters.accountWithBalanceAndCBA !== undefined) {
			queryParameters['accountWithBalanceAndCBA'] = requestParameters.accountWithBalanceAndCBA;
		}

		if (requestParameters.audit !== undefined) {
			queryParameters['audit'] = requestParameters.audit;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiKey'] = this.configuration.apiKey('X-Killbill-ApiKey'); // Killbill Api Key authentication
		}

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiSecret'] = this.configuration.apiKey('X-Killbill-ApiSecret'); // Killbill Api Secret authentication
		}

		if (
			this.configuration &&
			(this.configuration.username !== undefined || this.configuration.password !== undefined)
		) {
			headerParameters['Authorization'] =
				'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
		}
		const response = await this.request(
			{
				path: `/1.0/kb/accounts/search/{searchKey}`.replace(
					`{${'searchKey'}}`,
					encodeURIComponent(String(requestParameters.searchKey))
				),
				method: 'GET',
				headers: headerParameters,
				query: queryParameters
			},
			initOverrides
		);

		return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(AccountFromJSON));
	}

	/**
	 * Search accounts
	 */
	async searchAccounts(
		requestParameters: SearchAccountsRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<Array<Account>> {
		const response = await this.searchAccountsRaw(requestParameters, initOverrides);
		return await response.value();
	}

	/**
	 * Set the default payment method
	 */
	async setDefaultPaymentMethodRaw(
		requestParameters: SetDefaultPaymentMethodRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<void>> {
		if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
			throw new runtime.RequiredError(
				'accountId',
				'Required parameter requestParameters.accountId was null or undefined when calling setDefaultPaymentMethod.'
			);
		}

		if (
			requestParameters.paymentMethodId === null ||
			requestParameters.paymentMethodId === undefined
		) {
			throw new runtime.RequiredError(
				'paymentMethodId',
				'Required parameter requestParameters.paymentMethodId was null or undefined when calling setDefaultPaymentMethod.'
			);
		}

		if (
			requestParameters.xKillbillCreatedBy === null ||
			requestParameters.xKillbillCreatedBy === undefined
		) {
			throw new runtime.RequiredError(
				'xKillbillCreatedBy',
				'Required parameter requestParameters.xKillbillCreatedBy was null or undefined when calling setDefaultPaymentMethod.'
			);
		}

		const queryParameters: any = {};

		if (requestParameters.payAllUnpaidInvoices !== undefined) {
			queryParameters['payAllUnpaidInvoices'] = requestParameters.payAllUnpaidInvoices;
		}

		if (requestParameters.pluginProperty) {
			queryParameters['pluginProperty'] = requestParameters.pluginProperty;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		if (
			requestParameters.xKillbillCreatedBy !== undefined &&
			requestParameters.xKillbillCreatedBy !== null
		) {
			headerParameters['X-Killbill-CreatedBy'] = String(requestParameters.xKillbillCreatedBy);
		}

		if (
			requestParameters.xKillbillReason !== undefined &&
			requestParameters.xKillbillReason !== null
		) {
			headerParameters['X-Killbill-Reason'] = String(requestParameters.xKillbillReason);
		}

		if (
			requestParameters.xKillbillComment !== undefined &&
			requestParameters.xKillbillComment !== null
		) {
			headerParameters['X-Killbill-Comment'] = String(requestParameters.xKillbillComment);
		}

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiKey'] = this.configuration.apiKey('X-Killbill-ApiKey'); // Killbill Api Key authentication
		}

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiSecret'] = this.configuration.apiKey('X-Killbill-ApiSecret'); // Killbill Api Secret authentication
		}

		if (
			this.configuration &&
			(this.configuration.username !== undefined || this.configuration.password !== undefined)
		) {
			headerParameters['Authorization'] =
				'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
		}
		const response = await this.request(
			{
				path: `/1.0/kb/accounts/{accountId}/paymentMethods/{paymentMethodId}/setDefault`
					.replace(`{${'accountId'}}`, encodeURIComponent(String(requestParameters.accountId)))
					.replace(
						`{${'paymentMethodId'}}`,
						encodeURIComponent(String(requestParameters.paymentMethodId))
					),
				method: 'PUT',
				headers: headerParameters,
				query: queryParameters
			},
			initOverrides
		);

		return new runtime.VoidApiResponse(response);
	}

	/**
	 * Set the default payment method
	 */
	async setDefaultPaymentMethod(
		requestParameters: SetDefaultPaymentMethodRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<void> {
		await this.setDefaultPaymentMethodRaw(requestParameters, initOverrides);
	}

	/**
	 * Move a given child credit to the parent level
	 */
	async transferChildCreditToParentRaw(
		requestParameters: TransferChildCreditToParentRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<void>> {
		if (
			requestParameters.childAccountId === null ||
			requestParameters.childAccountId === undefined
		) {
			throw new runtime.RequiredError(
				'childAccountId',
				'Required parameter requestParameters.childAccountId was null or undefined when calling transferChildCreditToParent.'
			);
		}

		if (
			requestParameters.xKillbillCreatedBy === null ||
			requestParameters.xKillbillCreatedBy === undefined
		) {
			throw new runtime.RequiredError(
				'xKillbillCreatedBy',
				'Required parameter requestParameters.xKillbillCreatedBy was null or undefined when calling transferChildCreditToParent.'
			);
		}

		const queryParameters: any = {};

		const headerParameters: runtime.HTTPHeaders = {};

		if (
			requestParameters.xKillbillCreatedBy !== undefined &&
			requestParameters.xKillbillCreatedBy !== null
		) {
			headerParameters['X-Killbill-CreatedBy'] = String(requestParameters.xKillbillCreatedBy);
		}

		if (
			requestParameters.xKillbillReason !== undefined &&
			requestParameters.xKillbillReason !== null
		) {
			headerParameters['X-Killbill-Reason'] = String(requestParameters.xKillbillReason);
		}

		if (
			requestParameters.xKillbillComment !== undefined &&
			requestParameters.xKillbillComment !== null
		) {
			headerParameters['X-Killbill-Comment'] = String(requestParameters.xKillbillComment);
		}

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiKey'] = this.configuration.apiKey('X-Killbill-ApiKey'); // Killbill Api Key authentication
		}

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiSecret'] = this.configuration.apiKey('X-Killbill-ApiSecret'); // Killbill Api Secret authentication
		}

		if (
			this.configuration &&
			(this.configuration.username !== undefined || this.configuration.password !== undefined)
		) {
			headerParameters['Authorization'] =
				'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
		}
		const response = await this.request(
			{
				path: `/1.0/kb/accounts/{childAccountId}/transferCredit`.replace(
					`{${'childAccountId'}}`,
					encodeURIComponent(String(requestParameters.childAccountId))
				),
				method: 'PUT',
				headers: headerParameters,
				query: queryParameters
			},
			initOverrides
		);

		return new runtime.VoidApiResponse(response);
	}

	/**
	 * Move a given child credit to the parent level
	 */
	async transferChildCreditToParent(
		requestParameters: TransferChildCreditToParentRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<void> {
		await this.transferChildCreditToParentRaw(requestParameters, initOverrides);
	}

	/**
	 * Update account
	 */
	async updateAccountRaw(
		requestParameters: UpdateAccountRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<runtime.ApiResponse<void>> {
		if (requestParameters.body === null || requestParameters.body === undefined) {
			throw new runtime.RequiredError(
				'body',
				'Required parameter requestParameters.body was null or undefined when calling updateAccount.'
			);
		}

		if (requestParameters.accountId === null || requestParameters.accountId === undefined) {
			throw new runtime.RequiredError(
				'accountId',
				'Required parameter requestParameters.accountId was null or undefined when calling updateAccount.'
			);
		}

		if (
			requestParameters.xKillbillCreatedBy === null ||
			requestParameters.xKillbillCreatedBy === undefined
		) {
			throw new runtime.RequiredError(
				'xKillbillCreatedBy',
				'Required parameter requestParameters.xKillbillCreatedBy was null or undefined when calling updateAccount.'
			);
		}

		const queryParameters: any = {};

		if (requestParameters.treatNullAsReset !== undefined) {
			queryParameters['treatNullAsReset'] = requestParameters.treatNullAsReset;
		}

		const headerParameters: runtime.HTTPHeaders = {};

		headerParameters['Content-Type'] = 'application/json';

		if (
			requestParameters.xKillbillCreatedBy !== undefined &&
			requestParameters.xKillbillCreatedBy !== null
		) {
			headerParameters['X-Killbill-CreatedBy'] = String(requestParameters.xKillbillCreatedBy);
		}

		if (
			requestParameters.xKillbillReason !== undefined &&
			requestParameters.xKillbillReason !== null
		) {
			headerParameters['X-Killbill-Reason'] = String(requestParameters.xKillbillReason);
		}

		if (
			requestParameters.xKillbillComment !== undefined &&
			requestParameters.xKillbillComment !== null
		) {
			headerParameters['X-Killbill-Comment'] = String(requestParameters.xKillbillComment);
		}

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiKey'] = this.configuration.apiKey('X-Killbill-ApiKey'); // Killbill Api Key authentication
		}

		if (this.configuration && this.configuration.apiKey) {
			headerParameters['X-Killbill-ApiSecret'] = this.configuration.apiKey('X-Killbill-ApiSecret'); // Killbill Api Secret authentication
		}

		if (
			this.configuration &&
			(this.configuration.username !== undefined || this.configuration.password !== undefined)
		) {
			headerParameters['Authorization'] =
				'Basic ' + btoa(this.configuration.username + ':' + this.configuration.password);
		}
		const response = await this.request(
			{
				path: `/1.0/kb/accounts/{accountId}`.replace(
					`{${'accountId'}}`,
					encodeURIComponent(String(requestParameters.accountId))
				),
				method: 'PUT',
				headers: headerParameters,
				query: queryParameters,
				body: AccountToJSON(requestParameters.body)
			},
			initOverrides
		);

		return new runtime.VoidApiResponse(response);
	}

	/**
	 * Update account
	 */
	async updateAccount(
		requestParameters: UpdateAccountRequest,
		initOverrides?: RequestInit | runtime.InitOverrideFunction
	): Promise<void> {
		await this.updateAccountRaw(requestParameters, initOverrides);
	}
}

/**
 * @export
 */
export const GetAccountAuditEnum = {
	Full: 'FULL',
	Minimal: 'MINIMAL',
	None: 'NONE'
} as const;
export type GetAccountAuditEnum = (typeof GetAccountAuditEnum)[keyof typeof GetAccountAuditEnum];
/**
 * @export
 */
export const GetAccountBundlesAuditEnum = {
	Full: 'FULL',
	Minimal: 'MINIMAL',
	None: 'NONE'
} as const;
export type GetAccountBundlesAuditEnum =
	(typeof GetAccountBundlesAuditEnum)[keyof typeof GetAccountBundlesAuditEnum];
/**
 * @export
 */
export const GetAccountBundlesPaginatedAuditEnum = {
	Full: 'FULL',
	Minimal: 'MINIMAL',
	None: 'NONE'
} as const;
export type GetAccountBundlesPaginatedAuditEnum =
	(typeof GetAccountBundlesPaginatedAuditEnum)[keyof typeof GetAccountBundlesPaginatedAuditEnum];
/**
 * @export
 */
export const GetAccountByKeyAuditEnum = {
	Full: 'FULL',
	Minimal: 'MINIMAL',
	None: 'NONE'
} as const;
export type GetAccountByKeyAuditEnum =
	(typeof GetAccountByKeyAuditEnum)[keyof typeof GetAccountByKeyAuditEnum];
/**
 * @export
 */
export const GetAccountCustomFieldsAuditEnum = {
	Full: 'FULL',
	Minimal: 'MINIMAL',
	None: 'NONE'
} as const;
export type GetAccountCustomFieldsAuditEnum =
	(typeof GetAccountCustomFieldsAuditEnum)[keyof typeof GetAccountCustomFieldsAuditEnum];
/**
 * @export
 */
export const GetAccountTagsAuditEnum = {
	Full: 'FULL',
	Minimal: 'MINIMAL',
	None: 'NONE'
} as const;
export type GetAccountTagsAuditEnum =
	(typeof GetAccountTagsAuditEnum)[keyof typeof GetAccountTagsAuditEnum];
/**
 * @export
 */
export const GetAccountTimelineAuditEnum = {
	Full: 'FULL',
	Minimal: 'MINIMAL',
	None: 'NONE'
} as const;
export type GetAccountTimelineAuditEnum =
	(typeof GetAccountTimelineAuditEnum)[keyof typeof GetAccountTimelineAuditEnum];
/**
 * @export
 */
export const GetAccountsAuditEnum = {
	Full: 'FULL',
	Minimal: 'MINIMAL',
	None: 'NONE'
} as const;
export type GetAccountsAuditEnum = (typeof GetAccountsAuditEnum)[keyof typeof GetAccountsAuditEnum];
/**
 * @export
 */
export const GetAllCustomFieldsObjectTypeEnum = {
	Account: 'ACCOUNT',
	AccountEmail: 'ACCOUNT_EMAIL',
	BlockingStates: 'BLOCKING_STATES',
	Bundle: 'BUNDLE',
	CustomField: 'CUSTOM_FIELD',
	Invoice: 'INVOICE',
	Payment: 'PAYMENT',
	Transaction: 'TRANSACTION',
	InvoiceItem: 'INVOICE_ITEM',
	InvoicePayment: 'INVOICE_PAYMENT',
	Subscription: 'SUBSCRIPTION',
	SubscriptionEvent: 'SUBSCRIPTION_EVENT',
	ServiceBroadcast: 'SERVICE_BROADCAST',
	PaymentAttempt: 'PAYMENT_ATTEMPT',
	PaymentMethod: 'PAYMENT_METHOD',
	Tag: 'TAG',
	TagDefinition: 'TAG_DEFINITION',
	Tenant: 'TENANT',
	TenantKvs: 'TENANT_KVS'
} as const;
export type GetAllCustomFieldsObjectTypeEnum =
	(typeof GetAllCustomFieldsObjectTypeEnum)[keyof typeof GetAllCustomFieldsObjectTypeEnum];
/**
 * @export
 */
export const GetAllCustomFieldsAuditEnum = {
	Full: 'FULL',
	Minimal: 'MINIMAL',
	None: 'NONE'
} as const;
export type GetAllCustomFieldsAuditEnum =
	(typeof GetAllCustomFieldsAuditEnum)[keyof typeof GetAllCustomFieldsAuditEnum];
/**
 * @export
 */
export const GetAllTagsObjectTypeEnum = {
	Account: 'ACCOUNT',
	AccountEmail: 'ACCOUNT_EMAIL',
	BlockingStates: 'BLOCKING_STATES',
	Bundle: 'BUNDLE',
	CustomField: 'CUSTOM_FIELD',
	Invoice: 'INVOICE',
	Payment: 'PAYMENT',
	Transaction: 'TRANSACTION',
	InvoiceItem: 'INVOICE_ITEM',
	InvoicePayment: 'INVOICE_PAYMENT',
	Subscription: 'SUBSCRIPTION',
	SubscriptionEvent: 'SUBSCRIPTION_EVENT',
	ServiceBroadcast: 'SERVICE_BROADCAST',
	PaymentAttempt: 'PAYMENT_ATTEMPT',
	PaymentMethod: 'PAYMENT_METHOD',
	Tag: 'TAG',
	TagDefinition: 'TAG_DEFINITION',
	Tenant: 'TENANT',
	TenantKvs: 'TENANT_KVS'
} as const;
export type GetAllTagsObjectTypeEnum =
	(typeof GetAllTagsObjectTypeEnum)[keyof typeof GetAllTagsObjectTypeEnum];
/**
 * @export
 */
export const GetAllTagsAuditEnum = {
	Full: 'FULL',
	Minimal: 'MINIMAL',
	None: 'NONE'
} as const;
export type GetAllTagsAuditEnum = (typeof GetAllTagsAuditEnum)[keyof typeof GetAllTagsAuditEnum];
/**
 * @export
 */
export const GetBlockingStatesBlockingStateTypesEnum = {
	Subscription: 'SUBSCRIPTION',
	SubscriptionBundle: 'SUBSCRIPTION_BUNDLE',
	Account: 'ACCOUNT'
} as const;
export type GetBlockingStatesBlockingStateTypesEnum =
	(typeof GetBlockingStatesBlockingStateTypesEnum)[keyof typeof GetBlockingStatesBlockingStateTypesEnum];
/**
 * @export
 */
export const GetBlockingStatesAuditEnum = {
	Full: 'FULL',
	Minimal: 'MINIMAL',
	None: 'NONE'
} as const;
export type GetBlockingStatesAuditEnum =
	(typeof GetBlockingStatesAuditEnum)[keyof typeof GetBlockingStatesAuditEnum];
/**
 * @export
 */
export const GetChildrenAccountsAuditEnum = {
	Full: 'FULL',
	Minimal: 'MINIMAL',
	None: 'NONE'
} as const;
export type GetChildrenAccountsAuditEnum =
	(typeof GetChildrenAccountsAuditEnum)[keyof typeof GetChildrenAccountsAuditEnum];
/**
 * @export
 */
export const GetInvoicePaymentsAuditEnum = {
	Full: 'FULL',
	Minimal: 'MINIMAL',
	None: 'NONE'
} as const;
export type GetInvoicePaymentsAuditEnum =
	(typeof GetInvoicePaymentsAuditEnum)[keyof typeof GetInvoicePaymentsAuditEnum];
/**
 * @export
 */
export const GetInvoicesForAccountAuditEnum = {
	Full: 'FULL',
	Minimal: 'MINIMAL',
	None: 'NONE'
} as const;
export type GetInvoicesForAccountAuditEnum =
	(typeof GetInvoicesForAccountAuditEnum)[keyof typeof GetInvoicesForAccountAuditEnum];
/**
 * @export
 */
export const GetInvoicesForAccountPaginatedAuditEnum = {
	Full: 'FULL',
	Minimal: 'MINIMAL',
	None: 'NONE'
} as const;
export type GetInvoicesForAccountPaginatedAuditEnum =
	(typeof GetInvoicesForAccountPaginatedAuditEnum)[keyof typeof GetInvoicesForAccountPaginatedAuditEnum];
/**
 * @export
 */
export const GetPaymentMethodsForAccountAuditEnum = {
	Full: 'FULL',
	Minimal: 'MINIMAL',
	None: 'NONE'
} as const;
export type GetPaymentMethodsForAccountAuditEnum =
	(typeof GetPaymentMethodsForAccountAuditEnum)[keyof typeof GetPaymentMethodsForAccountAuditEnum];
/**
 * @export
 */
export const GetPaymentsForAccountAuditEnum = {
	Full: 'FULL',
	Minimal: 'MINIMAL',
	None: 'NONE'
} as const;
export type GetPaymentsForAccountAuditEnum =
	(typeof GetPaymentsForAccountAuditEnum)[keyof typeof GetPaymentsForAccountAuditEnum];
/**
 * @export
 */
export const SearchAccountsAuditEnum = {
	Full: 'FULL',
	Minimal: 'MINIMAL',
	None: 'NONE'
} as const;
export type SearchAccountsAuditEnum =
	(typeof SearchAccountsAuditEnum)[keyof typeof SearchAccountsAuditEnum];
