{"version":3,"file":"ChevronDownSolid-e15805e3.js","sources":["../../../../node_modules/.pnpm/flowbite-svelte-icons@0.4.5_svelte@4.2.8_tailwind-merge@2.2.0_tailwindcss@3.4.0/node_modules/flowbite-svelte-icons/dist/ChevronDownSolid.svelte","../../../../node_modules/.pnpm/flowbite-svelte@0.44.22_svelte@4.2.8/node_modules/flowbite-svelte/dist/dropdown/DropdownItem.svelte","../../../../node_modules/.pnpm/flowbite-svelte@0.44.22_svelte@4.2.8/node_modules/flowbite-svelte/dist/dropdown/Dropdown.svelte","../../../../node_modules/.pnpm/flowbite-svelte@0.44.22_svelte@4.2.8/node_modules/flowbite-svelte/dist/utils/Popper.svelte","../../../../node_modules/.pnpm/@floating-ui+dom@1.5.4/node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs","../../../../node_modules/.pnpm/@floating-ui+utils@0.2.1/node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs","../../../../node_modules/.pnpm/@floating-ui+core@1.5.3/node_modules/@floating-ui/core/dist/floating-ui.core.mjs","../../../../node_modules/.pnpm/@floating-ui+utils@0.2.1/node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs"],"sourcesContent":["<script>import { getContext } from \"svelte\";\nimport { twMerge } from \"tailwind-merge\";\nconst ctx = getContext(\"iconCtx\") ?? {};\nconst sizes = {\n    xs: \"w-3 h-3\",\n    sm: \"w-4 h-4\",\n    md: \"w-5 h-5\",\n    lg: \"w-6 h-6\",\n    xl: \"w-8 h-8\"\n};\nexport let size = ctx.size || \"md\";\nexport let role = ctx.role || \"img\";\nexport let ariaLabel = \"chevron down solid\";\n</script>\n\n<svg\n  xmlns=\"http://www.w3.org/2000/svg\"\n  fill=\"currentColor\"\n  {...$$restProps}\n  class={twMerge('shrink-0', sizes[size], $$props.class)}\n  {role}\n  aria-label={ariaLabel}\n  viewBox=\"0 0 10 6\"\n  on:click\n  on:keydown\n  on:keyup\n  on:focus\n  on:blur\n  on:mouseenter\n  on:mouseleave\n  on:mouseover\n  on:mouseout\n>\n  <path\n    fill=\"currentColor\"\n    d=\"M5.012 6a1 1 0 0 1-.707-.292l-4-3.992A.998.998 0 0 1 1.395.08a1 1 0 0 1 .324.224L5.012 3.59 8.305.305A1.001 1.001 0 0 1 10 1.014a.997.997 0 0 1-.28.702l-4 3.992A1.001 1.001 0 0 1 5.011 6Z\"\n  />\n</svg>\n\n<!--\n@component\n[Go to docs](https://flowbite-svelte-icons.vercel.app/)\n## Props\n@prop export let size: 'xs' | 'sm' | 'md' | 'lg' | 'xl' = ctx.size || 'md';\n@prop export let role = ctx.role || 'img';\n@prop export let ariaLabel = 'chevron down solid';\n-->\n","<script>import Wrapper from '../utils/Wrapper.svelte';\nimport { twMerge } from 'tailwind-merge';\nimport { getContext } from 'svelte';\nexport let defaultClass = 'font-medium py-2 px-4 text-sm hover:bg-gray-100 dark:hover:bg-gray-600';\nexport let href = undefined;\nexport let activeClass = undefined;\n// export let active: boolean = false;\nconst context = getContext('DropdownType') ?? {};\nconst activeUrlStore = getContext('activeUrl');\nlet sidebarUrl = '';\nactiveUrlStore.subscribe((value) => {\n    // console.log('value: ', value)\n    sidebarUrl = value;\n});\n$: active = sidebarUrl ? href === sidebarUrl : false;\n// let liClass: string;\n$: liClass = twMerge(defaultClass, href ? 'block' : 'w-full text-left', active && (activeClass ?? context.activeClass), $$props.class);\n// twMerge(active ? activeClass ?? context.activeClass : nonActiveClass ?? context.nonActiveClass, $$props.class);\n// console.log('active: ', active)\nlet wrap = true;\nfunction init(node) {\n    wrap = node.parentElement?.tagName === 'UL';\n}\n</script>\n\n<Wrapper tag=\"li\" show={wrap} use={init}>\n  <svelte:element this={href ? 'a' : 'button'} {href} type={href ? undefined : 'button'} role={href ? 'link' : 'button'} {...$$restProps} class={liClass} on:click on:change on:keydown on:keyup on:focus on:blur on:mouseenter on:mouseleave>\n    <slot />\n  </svelte:element>\n</Wrapper>\n\n<!--\n@component\n[Go to docs](https://flowbite-svelte.com/)\n## Props\n@prop export let defaultClass: string = 'font-medium py-2 px-4 text-sm hover:bg-gray-100 dark:hover:bg-gray-600';\n@prop export let href: string | undefined = undefined;\n@prop export let activeClass: string | undefined = undefined;\n@prop export let active: boolean = false;\n-->\n","<script context=\"module\">export {};\n</script>\n\n<script>import { twMerge } from 'tailwind-merge';\nimport Popper from '../utils/Popper.svelte';\nimport { setContext } from 'svelte';\nimport { writable } from 'svelte/store';\nconst activeUrlStore = writable('');\nexport let activeUrl = '';\nexport let open = false;\nexport let containerClass = 'divide-y z-50';\nexport let headerClass = 'py-1 overflow-hidden rounded-t-lg';\nexport let footerClass = 'py-1 overflow-hidden rounded-b-lg';\nexport let activeClass = 'text-primary-700 dark:text-primary-700 hover:text-primary-900 dark:hover:text-primary-900';\nlet activeCls = twMerge(activeClass, $$props.classActive);\nsetContext('DropdownType', { activeClass: activeCls });\n$: activeUrlStore.set(activeUrl);\nsetContext('activeUrl', activeUrlStore);\nlet containerCls = twMerge(containerClass, $$props.classContainer);\nlet headerCls = twMerge(headerClass, $$props.classHeader);\nlet ulCls = twMerge('py-1', $$props.class);\nlet footerCls = twMerge(footerClass, $$props.classFooter);\n$: {\n    // set default values\n    $$restProps.arrow = $$restProps.arrow ?? false;\n    $$restProps.trigger = $$restProps.trigger ?? 'click';\n    $$restProps.placement = $$restProps.placement ?? 'bottom';\n    $$restProps.color = $$restProps.color ?? 'dropdown';\n    $$restProps.shadow = $$restProps.shadow ?? true;\n    $$restProps.rounded = $$restProps.rounded ?? true;\n}\n</script>\n\n<Popper activeContent {...$$restProps} class={containerCls} on:show bind:open>\n  {#if $$slots.header}\n    <div class={headerCls}>\n      <slot name=\"header\" />\n    </div>\n  {/if}\n  <ul class={ulCls}>\n    <slot />\n  </ul>\n  {#if $$slots.footer}\n    <div class={footerCls}>\n      <slot name=\"footer\" />\n    </div>\n  {/if}\n</Popper>\n\n<!--\n@component\n[Go to docs](https://flowbite-svelte.com/)\n## Props\n@prop export let activeUrl: string = '';\n@prop export let open: boolean = false;\n@prop export let containerClass: string = 'divide-y z-50';\n@prop export let headerClass: string = 'py-1 overflow-hidden rounded-t-lg';\n@prop export let footerClass: string = 'py-1 overflow-hidden rounded-b-lg';\n@prop export let activeClass: string = 'text-primary-700 dark:text-primary-700 hover:text-primary-900 dark:hover:text-primary-900';\n-->\n","<script>import * as dom from '@floating-ui/dom';\nimport { onMount, createEventDispatcher } from 'svelte';\nimport { twJoin } from 'tailwind-merge';\nimport Frame from './Frame.svelte';\nexport let activeContent = false;\nexport let arrow = true;\nexport let offset = 8;\nexport let placement = 'top';\nexport let trigger = 'hover';\nexport let triggeredBy = undefined;\nexport let reference = undefined;\nexport let strategy = 'absolute';\nexport let open = false;\nexport let yOnly = false;\n// extra floating UI middleware list\nexport let middlewares = [dom.flip(), dom.shift()];\nconst dispatch = createEventDispatcher();\nlet clickable;\n$: clickable = trigger === 'click';\n$: dispatch('show', open);\n$: placement && (referenceEl = referenceEl);\nlet referenceEl;\nlet floatingEl;\nlet arrowEl;\nlet contentEl;\nlet triggerEls = [];\nlet _blocked = false; // management of the race condition between focusin and click events\nconst block = () => ((_blocked = true), setTimeout(() => (_blocked = false), 250));\nconst showHandler = (ev) => {\n    if (referenceEl === undefined)\n        console.error('trigger undefined');\n    if (!reference && triggerEls.includes(ev.target) && referenceEl !== ev.target) {\n        referenceEl = ev.target;\n        block();\n    }\n    if (clickable && ev.type === 'focusin' && !open)\n        block();\n    open = clickable && ev.type === 'click' && !_blocked ? !open : true;\n};\nconst hasHover = (el) => el.matches(':hover');\nconst hasFocus = (el) => el.contains(document.activeElement);\nconst px = (n) => (n != null ? `${n}px` : '');\nconst hideHandler = (ev) => {\n    if (activeContent) {\n        setTimeout(() => {\n            const elements = [referenceEl, floatingEl, ...triggerEls].filter(Boolean);\n            if (ev.type === 'mouseleave' && elements.some(hasHover))\n                return;\n            if (ev.type === 'focusout' && elements.some(hasFocus))\n                return;\n            open = false;\n        }, 100);\n    }\n    else\n        open = false;\n};\nlet arrowSide;\nconst oppositeSideMap = {\n    left: 'right',\n    right: 'left',\n    bottom: 'top',\n    top: 'bottom'\n};\n$: middleware = [...middlewares, dom.offset(+offset), arrowEl && dom.arrow({ element: arrowEl, padding: 10 })];\nfunction updatePosition() {\n    dom.computePosition(referenceEl, floatingEl, { placement, strategy, middleware }).then(({ x, y, middlewareData, placement, strategy }) => {\n        floatingEl.style.position = strategy;\n        floatingEl.style.left = yOnly ? '0' : px(x);\n        floatingEl.style.top = px(y);\n        if (middlewareData.arrow && arrowEl instanceof HTMLDivElement) {\n            arrowEl.style.left = px(middlewareData.arrow.x);\n            arrowEl.style.top = px(middlewareData.arrow.y);\n            arrowSide = oppositeSideMap[placement.split('-')[0]];\n            arrowEl.style[arrowSide] = px(-arrowEl.offsetWidth / 2 - ($$props.border ? 1 : 0));\n        }\n    });\n}\nfunction init(node, _referenceEl) {\n    floatingEl = node;\n    let cleanup = dom.autoUpdate(_referenceEl, floatingEl, updatePosition);\n    return {\n        update(_referenceEl) {\n            cleanup();\n            cleanup = dom.autoUpdate(_referenceEl, floatingEl, updatePosition);\n        },\n        destroy() {\n            cleanup();\n        }\n    };\n}\nonMount(() => {\n    const events = [\n        ['focusin', showHandler, true],\n        ['focusout', hideHandler, true],\n        ['click', showHandler, clickable],\n        ['mouseenter', showHandler, !clickable],\n        ['mouseleave', hideHandler, !clickable]\n    ];\n    if (triggeredBy)\n        triggerEls = [...document.querySelectorAll(triggeredBy)];\n    else\n        triggerEls = contentEl.previousElementSibling ? [contentEl.previousElementSibling] : [];\n    if (!triggerEls.length) {\n        console.error('No triggers found.');\n    }\n    triggerEls.forEach((element) => {\n        if (element.tabIndex < 0)\n            element.tabIndex = 0; // trigger must be focusable\n        for (const [name, handler, cond] of events)\n            if (cond)\n                element.addEventListener(name, handler);\n    });\n    if (reference) {\n        referenceEl = document.querySelector(reference) ?? document.body;\n        if (referenceEl === document.body) {\n            console.error(`Popup reference not found: '${reference}'`);\n        }\n        else {\n            referenceEl.addEventListener('focusout', hideHandler);\n            if (!clickable)\n                referenceEl.addEventListener('mouseleave', hideHandler);\n        }\n    }\n    else {\n        referenceEl = triggerEls[0];\n    }\n    return () => {\n        // This is onDestroy function\n        triggerEls.forEach((element) => {\n            if (element) {\n                for (const [name, handler] of events)\n                    element.removeEventListener(name, handler);\n            }\n        });\n        if (referenceEl) {\n            referenceEl.removeEventListener('focusout', hideHandler);\n            referenceEl.removeEventListener('mouseleave', hideHandler);\n        }\n    };\n});\nfunction optional(pred, func) {\n    return pred ? func : () => undefined;\n}\nlet arrowClass;\n$: arrowClass = twJoin('absolute pointer-events-none block w-[10px] h-[10px] rotate-45 bg-inherit border-inherit', $$props.border && arrowSide === 'bottom' && 'border-b border-e', $$props.border && arrowSide === 'top' && 'border-t border-s ', $$props.border && arrowSide === 'right' && 'border-t border-e ', $$props.border && arrowSide === 'left' && 'border-b border-s ');\nfunction initArrow(node) {\n    arrowEl = node;\n    return {\n        destroy() {\n            arrowEl = null;\n        }\n    };\n}\n</script>\n\n{#if !referenceEl}\n  <div bind:this={contentEl} />\n{/if}\n\n{#if open && referenceEl}\n  <Frame use={init} options={referenceEl} role=\"tooltip\" tabindex={activeContent ? -1 : undefined} on:focusin={optional(activeContent, showHandler)} on:focusout={optional(activeContent, hideHandler)} on:mouseenter={optional(activeContent && !clickable, showHandler)} on:mouseleave={optional(activeContent && !clickable, hideHandler)} {...$$restProps}>\n    <slot />\n    {#if arrow}<div use:initArrow class={arrowClass} />{/if}\n  </Frame>\n{/if}\n\n<!--\n@component\n[Go to docs](https://flowbite-svelte.com/)\n## Props\n@prop export let activeContent: boolean = false;\n@prop export let arrow: boolean = true;\n@prop export let offset: number = 8;\n@prop export let placement: Placement = 'top';\n@prop export let trigger: 'hover' | 'click' = 'hover';\n@prop export let triggeredBy: string | undefined = undefined;\n@prop export let reference: string | undefined = undefined;\n@prop export let strategy: 'absolute' | 'fixed' = 'absolute';\n@prop export let open: boolean = false;\n@prop export let yOnly: boolean = false;\n@prop export let middlewares: Middleware[] = [dom.flip(), dom.shift()];\n-->\n","import { rectToClientRect, autoPlacement as autoPlacement$1, shift as shift$1, flip as flip$1, size as size$1, hide as hide$1, arrow as arrow$1, inline as inline$1, limitShift as limitShift$1, computePosition as computePosition$1 } from '@floating-ui/core';\nexport { detectOverflow, offset } from '@floating-ui/core';\nimport { round, createCoords, max, min, floor } from '@floating-ui/utils';\nimport { getComputedStyle, isHTMLElement, isElement, getWindow, isWebKit, getDocumentElement, getNodeName, isOverflowElement, getNodeScroll, getOverflowAncestors, getParentNode, isLastTraversableNode, isContainingBlock, isTableElement, getContainingBlock } from '@floating-ui/utils/dom';\nexport { getOverflowAncestors } from '@floating-ui/utils/dom';\n\nfunction getCssDimensions(element) {\n  const css = getComputedStyle(element);\n  // In testing environments, the `width` and `height` properties are empty\n  // strings for SVG elements, returning NaN. Fallback to `0` in this case.\n  let width = parseFloat(css.width) || 0;\n  let height = parseFloat(css.height) || 0;\n  const hasOffset = isHTMLElement(element);\n  const offsetWidth = hasOffset ? element.offsetWidth : width;\n  const offsetHeight = hasOffset ? element.offsetHeight : height;\n  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n  return {\n    width,\n    height,\n    $: shouldFallback\n  };\n}\n\nfunction unwrapElement(element) {\n  return !isElement(element) ? element.contextElement : element;\n}\n\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n  if (!isHTMLElement(domElement)) {\n    return createCoords(1);\n  }\n  const rect = domElement.getBoundingClientRect();\n  const {\n    width,\n    height,\n    $\n  } = getCssDimensions(domElement);\n  let x = ($ ? round(rect.width) : rect.width) / width;\n  let y = ($ ? round(rect.height) : rect.height) / height;\n\n  // 0, NaN, or Infinity should always fallback to 1.\n\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n  return {\n    x,\n    y\n  };\n}\n\nconst noOffsets = /*#__PURE__*/createCoords(0);\nfunction getVisualOffsets(element) {\n  const win = getWindow(element);\n  if (!isWebKit() || !win.visualViewport) {\n    return noOffsets;\n  }\n  return {\n    x: win.visualViewport.offsetLeft,\n    y: win.visualViewport.offsetTop\n  };\n}\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {\n    return false;\n  }\n  return isFixed;\n}\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  const domElement = unwrapElement(element);\n  let scale = createCoords(1);\n  if (includeScale) {\n    if (offsetParent) {\n      if (isElement(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);\n  let x = (clientRect.left + visualOffsets.x) / scale.x;\n  let y = (clientRect.top + visualOffsets.y) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n  if (domElement) {\n    const win = getWindow(domElement);\n    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n    let currentIFrame = win.frameElement;\n    while (currentIFrame && offsetParent && offsetWin !== win) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = getComputedStyle(currentIFrame);\n      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += left;\n      y += top;\n      currentIFrame = getWindow(currentIFrame).frameElement;\n    }\n  }\n  return rectToClientRect({\n    width,\n    height,\n    x,\n    y\n  });\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  if (offsetParent === documentElement) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  let scale = createCoords(1);\n  const offsets = createCoords(0);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n  }\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y\n  };\n}\n\nfunction getClientRects(element) {\n  return Array.from(element.getClientRects());\n}\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n}\n\n// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\nfunction getDocumentRect(element) {\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = element.ownerDocument.body;\n  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (getComputedStyle(body).direction === 'rtl') {\n    x += max(html.clientWidth, body.clientWidth) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const visualViewportBased = isWebKit();\n    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// Returns the inner client rect, subtracting scrollbars if present.\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  let rect;\n  if (clippingAncestor === 'viewport') {\n    rect = getViewportRect(element, strategy);\n  } else if (clippingAncestor === 'document') {\n    rect = getDocumentRect(getDocumentElement(element));\n  } else if (isElement(clippingAncestor)) {\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n  } else {\n    const visualOffsets = getVisualOffsets(element);\n    rect = {\n      ...clippingAncestor,\n      x: clippingAncestor.x - visualOffsets.x,\n      y: clippingAncestor.y - visualOffsets.y\n    };\n  }\n  return rectToClientRect(rect);\n}\nfunction hasFixedPositionAncestor(element, stopNode) {\n  const parentNode = getParentNode(element);\n  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {\n    return false;\n  }\n  return getComputedStyle(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);\n}\n\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n  if (cachedResult) {\n    return cachedResult;\n  }\n  let result = getOverflowAncestors(element, [], false).filter(el => isElement(el) && getNodeName(el) !== 'body');\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = getComputedStyle(element).position === 'fixed';\n  let currentNode = elementIsFixed ? getParentNode(element) : element;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    const computedStyle = getComputedStyle(currentNode);\n    const currentNodeIsContaining = isContainingBlock(currentNode);\n    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {\n      currentContainingBlockComputedStyle = null;\n    }\n    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n    if (shouldDropCurrentNode) {\n      // Drop non-containing blocks.\n      result = result.filter(ancestor => ancestor !== currentNode);\n    } else {\n      // Record last containing block for next iteration.\n      currentContainingBlockComputedStyle = computedStyle;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  cache.set(element, result);\n  return result;\n}\n\n// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === 'clippingAncestors' ? getClippingElementAncestors(element, this._c) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nfunction getDimensions(element) {\n  const {\n    width,\n    height\n  } = getCssDimensions(element);\n  return {\n    width,\n    height\n  };\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const isFixed = strategy === 'fixed';\n  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = createCoords(0);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isOffsetParentAnElement) {\n      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction getTrueOffsetParent(element, polyfill) {\n  if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n  if (polyfill) {\n    return polyfill(element);\n  }\n  return element.offsetParent;\n}\n\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element, polyfill) {\n  const window = getWindow(element);\n  if (!isHTMLElement(element)) {\n    return window;\n  }\n  let offsetParent = getTrueOffsetParent(element, polyfill);\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n  }\n  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {\n    return window;\n  }\n  return offsetParent || getContainingBlock(element) || window;\n}\n\nconst getElementRects = async function (_ref) {\n  let {\n    reference,\n    floating,\n    strategy\n  } = _ref;\n  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n  const getDimensionsFn = this.getDimensions;\n  return {\n    reference: getRectRelativeToOffsetParent(reference, await getOffsetParentFn(floating), strategy),\n    floating: {\n      x: 0,\n      y: 0,\n      ...(await getDimensionsFn(floating))\n    }\n  };\n};\n\nfunction isRTL(element) {\n  return getComputedStyle(element).direction === 'rtl';\n}\n\nconst platform = {\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  getDocumentElement,\n  getClippingRect,\n  getOffsetParent,\n  getElementRects,\n  getClientRects,\n  getDimensions,\n  getScale,\n  isElement,\n  isRTL\n};\n\n// https://samthor.au/2021/observing-dom/\nfunction observeMove(element, onMove) {\n  let io = null;\n  let timeoutId;\n  const root = getDocumentElement(element);\n  function cleanup() {\n    clearTimeout(timeoutId);\n    io && io.disconnect();\n    io = null;\n  }\n  function refresh(skip, threshold) {\n    if (skip === void 0) {\n      skip = false;\n    }\n    if (threshold === void 0) {\n      threshold = 1;\n    }\n    cleanup();\n    const {\n      left,\n      top,\n      width,\n      height\n    } = element.getBoundingClientRect();\n    if (!skip) {\n      onMove();\n    }\n    if (!width || !height) {\n      return;\n    }\n    const insetTop = floor(top);\n    const insetRight = floor(root.clientWidth - (left + width));\n    const insetBottom = floor(root.clientHeight - (top + height));\n    const insetLeft = floor(left);\n    const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n    const options = {\n      rootMargin,\n      threshold: max(0, min(1, threshold)) || 1\n    };\n    let isFirstUpdate = true;\n    function handleObserve(entries) {\n      const ratio = entries[0].intersectionRatio;\n      if (ratio !== threshold) {\n        if (!isFirstUpdate) {\n          return refresh();\n        }\n        if (!ratio) {\n          timeoutId = setTimeout(() => {\n            refresh(false, 1e-7);\n          }, 100);\n        } else {\n          refresh(false, ratio);\n        }\n      }\n      isFirstUpdate = false;\n    }\n\n    // Older browsers don't support a `document` as the root and will throw an\n    // error.\n    try {\n      io = new IntersectionObserver(handleObserve, {\n        ...options,\n        // Handle <iframe>s\n        root: root.ownerDocument\n      });\n    } catch (e) {\n      io = new IntersectionObserver(handleObserve, options);\n    }\n    io.observe(element);\n  }\n  refresh(true);\n  return cleanup;\n}\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = typeof ResizeObserver === 'function',\n    layoutShift = typeof IntersectionObserver === 'function',\n    animationFrame = false\n  } = options;\n  const referenceEl = unwrapElement(reference);\n  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n  let reobserveFrame = -1;\n  let resizeObserver = null;\n  if (elementResize) {\n    resizeObserver = new ResizeObserver(_ref => {\n      let [firstEntry] = _ref;\n      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n        // Prevent update loops when using the `size` middleware.\n        // https://github.com/floating-ui/floating-ui/issues/1740\n        resizeObserver.unobserve(floating);\n        cancelAnimationFrame(reobserveFrame);\n        reobserveFrame = requestAnimationFrame(() => {\n          resizeObserver && resizeObserver.observe(floating);\n        });\n      }\n      update();\n    });\n    if (referenceEl && !animationFrame) {\n      resizeObserver.observe(referenceEl);\n    }\n    resizeObserver.observe(floating);\n  }\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n  if (animationFrame) {\n    frameLoop();\n  }\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n      update();\n    }\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n  update();\n  return () => {\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    cleanupIo && cleanupIo();\n    resizeObserver && resizeObserver.disconnect();\n    resizeObserver = null;\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = autoPlacement$1;\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = shift$1;\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = flip$1;\n\n/**\n * Provides data that allows you to change the size of the floating element â€”\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = size$1;\n\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = hide$1;\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = arrow$1;\n\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = inline$1;\n\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = limitShift$1;\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n */\nconst computePosition = (reference, floating, options) => {\n  // This caches the expensive `getClippingElementAncestors` function so that\n  // multiple lifecycle resets re-use the same result. It only lives for a\n  // single call. If other functions become expensive, we can add them as well.\n  const cache = new Map();\n  const mergedOptions = {\n    platform,\n    ...options\n  };\n  const platformWithCache = {\n    ...mergedOptions.platform,\n    _c: cache\n  };\n  return computePosition$1(reference, floating, {\n    ...mergedOptions,\n    platform: platformWithCache\n  });\n};\n\nexport { arrow, autoPlacement, autoUpdate, computePosition, flip, hide, inline, limitShift, platform, shift, size };\n","function getNodeName(node) {\n  if (isNode(node)) {\n    return (node.nodeName || '').toLowerCase();\n  }\n  // Mocked nodes in testing environments may not be instances of Node. By\n  // returning `#document` an infinite loop won't occur.\n  // https://github.com/floating-ui/floating-ui/issues/2317\n  return '#document';\n}\nfunction getWindow(node) {\n  var _node$ownerDocument;\n  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\nfunction getDocumentElement(node) {\n  var _ref;\n  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;\n}\nfunction isNode(value) {\n  return value instanceof Node || value instanceof getWindow(value).Node;\n}\nfunction isElement(value) {\n  return value instanceof Element || value instanceof getWindow(value).Element;\n}\nfunction isHTMLElement(value) {\n  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;\n}\nfunction isShadowRoot(value) {\n  // Browsers without `ShadowRoot` support.\n  if (typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;\n}\nfunction isOverflowElement(element) {\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle(element);\n  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);\n}\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].includes(getNodeName(element));\n}\nfunction isContainingBlock(element) {\n  const webkit = isWebKit();\n  const css = getComputedStyle(element);\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  return css.transform !== 'none' || css.perspective !== 'none' || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || ['transform', 'perspective', 'filter'].some(value => (css.willChange || '').includes(value)) || ['paint', 'layout', 'strict', 'content'].some(value => (css.contain || '').includes(value));\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else {\n      currentNode = getParentNode(currentNode);\n    }\n  }\n  return null;\n}\nfunction isWebKit() {\n  if (typeof CSS === 'undefined' || !CSS.supports) return false;\n  return CSS.supports('-webkit-backdrop-filter', 'none');\n}\nfunction isLastTraversableNode(node) {\n  return ['html', 'body', '#document'].includes(getNodeName(node));\n}\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.pageXOffset,\n    scrollTop: element.pageYOffset\n  };\n}\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n  const result =\n  // Step into the shadow DOM of the parent of a slotted node.\n  node.assignedSlot ||\n  // DOM Element detected.\n  node.parentNode ||\n  // ShadowRoot detected.\n  isShadowRoot(node) && node.host ||\n  // Fallback.\n  getDocumentElement(node);\n  return isShadowRoot(result) ? result.host : result;\n}\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    return node.ownerDocument ? node.ownerDocument.body : node.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list, traverseIframes) {\n  var _node$ownerDocument2;\n  if (list === void 0) {\n    list = [];\n  }\n  if (traverseIframes === void 0) {\n    traverseIframes = true;\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));\n}\n\nexport { getComputedStyle, getContainingBlock, getDocumentElement, getNearestOverflowAncestor, getNodeName, getNodeScroll, getOverflowAncestors, getParentNode, getWindow, isContainingBlock, isElement, isHTMLElement, isLastTraversableNode, isNode, isOverflowElement, isShadowRoot, isTableElement, isWebKit };\n","import { getSideAxis, getAlignmentAxis, getAxisLength, getSide, getAlignment, evaluate, getPaddingObject, rectToClientRect, min, clamp, placements, getAlignmentSides, getOppositeAlignmentPlacement, getOppositePlacement, getExpandedPlacements, getOppositeAxisPlacements, sides, max, getOppositeAxis } from '@floating-ui/utils';\nexport { rectToClientRect } from '@floating-ui/utils';\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const sideAxis = getSideAxis(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const alignLength = getAxisLength(alignmentAxis);\n  const side = getSide(placement);\n  const isVertical = sideAxis === 'y';\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n  let coords;\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case 'end':\n      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\nconst computePosition = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const validMiddleware = middleware.filter(Boolean);\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n  for (let i = 0; i < validMiddleware.length; i++) {\n    const {\n      name,\n      fn\n    } = validMiddleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = {\n      ...middlewareData,\n      [name]: {\n        ...middlewareData[name],\n        ...data\n      }\n    };\n    if (reset && resetCount <= 50) {\n      resetCount++;\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n      i = -1;\n      continue;\n    }\n  }\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(state, options) {\n  var _await$platform$isEle;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = state;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = evaluate(options, state);\n  const paddingObject = getPaddingObject(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const rect = elementContext === 'floating' ? {\n    ...rects.floating,\n    x,\n    y\n  } : rects.reference;\n  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\n  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {\n    x: 1,\n    y: 1\n  } : {\n    x: 1,\n    y: 1\n  };\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    rect,\n    offsetParent,\n    strategy\n  }) : rect);\n  return {\n    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n  };\n}\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n  async fn(state) {\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform,\n      elements,\n      middlewareData\n    } = state;\n    // Since `element` is required, we don't Partial<> the type.\n    const {\n      element,\n      padding = 0\n    } = evaluate(options, state) || {};\n    if (element == null) {\n      return {};\n    }\n    const paddingObject = getPaddingObject(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getAlignmentAxis(placement);\n    const length = getAxisLength(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const isYAxis = axis === 'y';\n    const minProp = isYAxis ? 'top' : 'left';\n    const maxProp = isYAxis ? 'bottom' : 'right';\n    const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n\n    // DOM platform can return `window` as the `offsetParent`.\n    if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {\n      clientSize = elements.floating[clientProp] || rects.floating[length];\n    }\n    const centerToReference = endDiff / 2 - startDiff / 2;\n\n    // If the padding is large enough that it causes the arrow to no longer be\n    // centered, modify the padding so that it is centered.\n    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\n    const minPadding = min(paddingObject[minProp], largestPossiblePadding);\n    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);\n\n    // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds.\n    const min$1 = minPadding;\n    const max = clientSize - arrowDimensions[length] - maxPadding;\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = clamp(min$1, center, max);\n\n    // If the reference is small enough that the arrow's padding causes it to\n    // to point to nothing for an aligned placement, adjust the offset of the\n    // floating element itself. To ensure `shift()` continues to take action,\n    // a single reset is performed when this is true.\n    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center != offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\n    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;\n    return {\n      [axis]: coords[axis] + alignmentOffset,\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset - alignmentOffset,\n        ...(shouldAddOffset && {\n          alignmentOffset\n        })\n      },\n      reset: shouldAddOffset\n    };\n  }\n});\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n    return true;\n  });\n}\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'autoPlacement',\n    options,\n    async fn(state) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;\n      const {\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = state;\n      const {\n        crossAxis = false,\n        alignment,\n        allowedPlacements = placements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const placements$1 = alignment !== undefined || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\n      const currentPlacement = placements$1[currentIndex];\n      if (currentPlacement == null) {\n        return {};\n      }\n      const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n\n      // Make `computeCoords` start from the right place.\n      if (placement !== currentPlacement) {\n        return {\n          reset: {\n            placement: placements$1[0]\n          }\n        };\n      }\n      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];\n      const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements$1[currentIndex + 1];\n\n      // There are more placements to check.\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n      const placementsSortedByMostSpace = allOverflows.map(d => {\n        const alignment = getAlignment(d.placement);\n        return [d.placement, alignment && crossAxis ?\n        // Check along the mainAxis and main crossAxis side.\n        d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :\n        // Check only the mainAxis.\n        d.overflows[0], d.overflows];\n      }).sort((a, b) => a[1] - b[1]);\n      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,\n      // Aligned placements should not check their opposite crossAxis\n      // side.\n      getAlignment(d[0]) ? 2 : 3).every(v => v <= 0));\n      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'flip',\n    options,\n    async fn(state) {\n      var _middlewareData$arrow, _middlewareData$flip;\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        fallbackAxisSideDirection = 'none',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n\n      // If a reset by the arrow was caused due to an alignment offset being\n      // added, we should skip any logic now since `flip()` has already done its\n      // work.\n      // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643\n      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      const side = getSide(placement);\n      const isBasePlacement = getSide(initialPlacement) === initialPlacement;\n      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== 'none') {\n        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n      }\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n      if (checkCrossAxis) {\n        const sides = getAlignmentSides(placement, rects, rtl);\n        overflows.push(overflow[sides[0]], overflow[sides[1]]);\n      }\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }];\n\n      // One or more sides is overflowing.\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip2, _overflowsData$filter;\n        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n        const nextPlacement = placements[nextIndex];\n        if (nextPlacement) {\n          // Try next placement and re-run the lifecycle.\n          return {\n            data: {\n              index: nextIndex,\n              overflows: overflowsData\n            },\n            reset: {\n              placement: nextPlacement\n            }\n          };\n        }\n\n        // First, find the candidates that fit on the mainAxis side of overflow,\n        // then find the placement that fits the best on the main crossAxis side.\n        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n\n        // Otherwise fallback.\n        if (!resetPlacement) {\n          switch (fallbackStrategy) {\n            case 'bestFit':\n              {\n                var _overflowsData$map$so;\n                const placement = (_overflowsData$map$so = overflowsData.map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0];\n                if (placement) {\n                  resetPlacement = placement;\n                }\n                break;\n              }\n            case 'initialPlacement':\n              resetPlacement = initialPlacement;\n              break;\n          }\n        }\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n      return {};\n    }\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'hide',\n    options,\n    async fn(state) {\n      const {\n        rects\n      } = state;\n      const {\n        strategy = 'referenceHidden',\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        default:\n          {\n            return {};\n          }\n      }\n    }\n  };\n};\n\nfunction getBoundingRect(rects) {\n  const minX = min(...rects.map(rect => rect.left));\n  const minY = min(...rects.map(rect => rect.top));\n  const maxX = max(...rects.map(rect => rect.right));\n  const maxY = max(...rects.map(rect => rect.bottom));\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\nfunction getRectsByLine(rects) {\n  const sortedRects = rects.slice().sort((a, b) => a.y - b.y);\n  const groups = [];\n  let prevRect = null;\n  for (let i = 0; i < sortedRects.length; i++) {\n    const rect = sortedRects[i];\n    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {\n      groups.push([rect]);\n    } else {\n      groups[groups.length - 1].push(rect);\n    }\n    prevRect = rect;\n  }\n  return groups.map(rect => rectToClientRect(getBoundingRect(rect)));\n}\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'inline',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        elements,\n        rects,\n        platform,\n        strategy\n      } = state;\n      // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n      // ClientRect's bounds, despite the event listener being triggered. A\n      // padding of 2 seems to handle this issue.\n      const {\n        padding = 2,\n        x,\n        y\n      } = evaluate(options, state);\n      const nativeClientRects = Array.from((await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) || []);\n      const clientRects = getRectsByLine(nativeClientRects);\n      const fallback = rectToClientRect(getBoundingRect(nativeClientRects));\n      const paddingObject = getPaddingObject(padding);\n      function getBoundingClientRect() {\n        // There are two rects and they are disjoined.\n        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n          // Find the first rect in which the point is fully inside.\n          return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;\n        }\n\n        // There are 2 or more connected rects.\n        if (clientRects.length >= 2) {\n          if (getSideAxis(placement) === 'y') {\n            const firstRect = clientRects[0];\n            const lastRect = clientRects[clientRects.length - 1];\n            const isTop = getSide(placement) === 'top';\n            const top = firstRect.top;\n            const bottom = lastRect.bottom;\n            const left = isTop ? firstRect.left : lastRect.left;\n            const right = isTop ? firstRect.right : lastRect.right;\n            const width = right - left;\n            const height = bottom - top;\n            return {\n              top,\n              bottom,\n              left,\n              right,\n              width,\n              height,\n              x: left,\n              y: top\n            };\n          }\n          const isLeftSide = getSide(placement) === 'left';\n          const maxRight = max(...clientRects.map(rect => rect.right));\n          const minLeft = min(...clientRects.map(rect => rect.left));\n          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n          const top = measureRects[0].top;\n          const bottom = measureRects[measureRects.length - 1].bottom;\n          const left = minLeft;\n          const right = maxRight;\n          const width = right - left;\n          const height = bottom - top;\n          return {\n            top,\n            bottom,\n            left,\n            right,\n            width,\n            height,\n            x: left,\n            y: top\n          };\n        }\n        return fallback;\n      }\n      const resetRects = await platform.getElementRects({\n        reference: {\n          getBoundingClientRect\n        },\n        floating: elements.floating,\n        strategy\n      });\n      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n        return {\n          reset: {\n            rects: resetRects\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n// For type backwards-compatibility, the `OffsetOptions` type was also\n// Derivable.\n\nasync function convertValueToCoords(state, options) {\n  const {\n    placement,\n    platform,\n    elements\n  } = state;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getSideAxis(placement) === 'y';\n  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = evaluate(options, state);\n\n  // eslint-disable-next-line prefer-const\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: 0,\n    crossAxis: 0,\n    alignmentAxis: null,\n    ...rawValue\n  };\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = function (options) {\n  if (options === void 0) {\n    options = 0;\n  }\n  return {\n    name: 'offset',\n    options,\n    async fn(state) {\n      var _middlewareData$offse, _middlewareData$arrow;\n      const {\n        x,\n        y,\n        placement,\n        middlewareData\n      } = state;\n      const diffCoords = await convertValueToCoords(state, options);\n\n      // If the placement is the same and the arrow caused an alignment offset\n      // then we don't need to change the positioning coordinates.\n      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: {\n          ...diffCoords,\n          placement\n        }\n      };\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'shift',\n    options,\n    async fn(state) {\n      const {\n        x,\n        y,\n        placement\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const crossAxis = getSideAxis(getSide(placement));\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = clamp(min, mainAxisCoord, max);\n      }\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = clamp(min, crossAxisCoord, max);\n      }\n      const limitedCoords = limiter.fn({\n        ...state,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return {\n        ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y\n        }\n      };\n    }\n  };\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    options,\n    fn(state) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        middlewareData\n      } = state;\n      const {\n        offset = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const crossAxis = getSideAxis(placement);\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = evaluate(offset, state);\n      const computedOffset = typeof rawOffset === 'number' ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        ...rawOffset\n      };\n      if (checkMainAxis) {\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2;\n        const len = mainAxis === 'y' ? 'width' : 'height';\n        const isOriginSide = ['top', 'left'].includes(getSide(placement));\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      };\n    }\n  };\n};\n\n/**\n * Provides data that allows you to change the size of the floating element â€”\n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'size',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        rects,\n        platform,\n        elements\n      } = state;\n      const {\n        apply = () => {},\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const side = getSide(placement);\n      const alignment = getAlignment(placement);\n      const isYAxis = getSideAxis(placement) === 'y';\n      const {\n        width,\n        height\n      } = rects.floating;\n      let heightSide;\n      let widthSide;\n      if (side === 'top' || side === 'bottom') {\n        heightSide = side;\n        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\n      } else {\n        widthSide = side;\n        heightSide = alignment === 'end' ? 'top' : 'bottom';\n      }\n      const overflowAvailableHeight = height - overflow[heightSide];\n      const overflowAvailableWidth = width - overflow[widthSide];\n      const noShift = !state.middlewareData.shift;\n      let availableHeight = overflowAvailableHeight;\n      let availableWidth = overflowAvailableWidth;\n      if (isYAxis) {\n        const maximumClippingWidth = width - overflow.left - overflow.right;\n        availableWidth = alignment || noShift ? min(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;\n      } else {\n        const maximumClippingHeight = height - overflow.top - overflow.bottom;\n        availableHeight = alignment || noShift ? min(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;\n      }\n      if (noShift && !alignment) {\n        const xMin = max(overflow.left, 0);\n        const xMax = max(overflow.right, 0);\n        const yMin = max(overflow.top, 0);\n        const yMax = max(overflow.bottom, 0);\n        if (isYAxis) {\n          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));\n        } else {\n          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));\n        }\n      }\n      await apply({\n        ...state,\n        availableWidth,\n        availableHeight\n      });\n      const nextDimensions = await platform.getDimensions(elements.floating);\n      if (width !== nextDimensions.width || height !== nextDimensions.height) {\n        return {\n          reset: {\n            rects: true\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nexport { arrow, autoPlacement, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, shift, size };\n","/**\n * Custom positioning reference element.\n * @see https://floating-ui.com/docs/virtual-elements\n */\n\nconst sides = ['top', 'right', 'bottom', 'left'];\nconst alignments = ['start', 'end'];\nconst placements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-\" + alignments[0], side + \"-\" + alignments[1]), []);\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nconst floor = Math.floor;\nconst createCoords = v => ({\n  x: v,\n  y: v\n});\nconst oppositeSideMap = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nconst oppositeAlignmentMap = {\n  start: 'end',\n  end: 'start'\n};\nfunction clamp(start, value, end) {\n  return max(start, min(value, end));\n}\nfunction evaluate(value, param) {\n  return typeof value === 'function' ? value(param) : value;\n}\nfunction getSide(placement) {\n  return placement.split('-')[0];\n}\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\nfunction getOppositeAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\nfunction getAxisLength(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\nfunction getSideAxis(placement) {\n  return ['top', 'bottom'].includes(getSide(placement)) ? 'y' : 'x';\n}\nfunction getAlignmentAxis(placement) {\n  return getOppositeAxis(getSideAxis(placement));\n}\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n  const alignment = getAlignment(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const length = getAxisLength(alignmentAxis);\n  let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];\n}\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);\n}\nfunction getSideList(side, isStart, rtl) {\n  const lr = ['left', 'right'];\n  const rl = ['right', 'left'];\n  const tb = ['top', 'bottom'];\n  const bt = ['bottom', 'top'];\n  switch (side) {\n    case 'top':\n    case 'bottom':\n      if (rtl) return isStart ? rl : lr;\n      return isStart ? lr : rl;\n    case 'left':\n    case 'right':\n      return isStart ? tb : bt;\n    default:\n      return [];\n  }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n  const alignment = getAlignment(placement);\n  let list = getSideList(getSide(placement), direction === 'start', rtl);\n  if (alignment) {\n    list = list.map(side => side + \"-\" + alignment);\n    if (flipAlignment) {\n      list = list.concat(list.map(getOppositeAlignmentPlacement));\n    }\n  }\n  return list;\n}\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);\n}\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\nfunction getPaddingObject(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\nfunction rectToClientRect(rect) {\n  return {\n    ...rect,\n    top: rect.y,\n    left: rect.x,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  };\n}\n\nexport { alignments, clamp, createCoords, evaluate, expandPaddingObject, floor, getAlignment, getAlignmentAxis, getAlignmentSides, getAxisLength, getExpandedPlacements, getOppositeAlignmentPlacement, getOppositeAxis, getOppositeAxisPlacements, getOppositePlacement, getPaddingObject, getSide, getSideAxis, max, min, placements, rectToClientRect, round, sides };\n"],"names":["dom.offset","offset","dom.autoUpdate","_referenceEl","oppositeSideMap","placement","strategy","dom.computePosition","dom.flip","dom.shift","window","min","max","y","x","shift","platform","overflow","side","flip","computePosition"],"mappings":";;;;;;;AOQA,MAAM,GAAN,GAAY,IAAZ,CAAiB,GAAjB,CAAA;AACA,MAAM,GAAN,GAAY,IAAZ,CAAiB,GAAjB,CAAA;AACA,MAAM,KAAN,GAAc,IAAd,CAAmB,KAAnB,CAAA;AACA,MAAM,KAAN,GAAc,IAAd,CAAmB,KAAnB,CAAA;AACA,MAAM,YAAN,GAAqB,CAArB,CAAA,MAA2B;AAAA,EACzB,CADF,EACK,CADL;AACK,EACH,CADF,EACK,CADL;AAEA,CAAA,CAAA,CAAA;AACA,MAAM,eAAN,GAAwB;AAAA,EACtB,IADF,EACQ,OADR;AACQ,EACN,KADF,EACS,MADT;AACS,EACP,MADF,EACU,KADV;AACU,EACR,GADF,EACO,QADP;AAEA,CAAA,CAAA;AACA,MAAM,oBAAN,GAA6B;AAAA,EAC3B,KADF,EACS,KADT;AACS,EACP,GADF,EACO,OADP;AAEA,CAAA,CAAA;AACA,SAAS,KAAT,CAAe,KAAf,EAAsB,KAAtB,EAA6B,GAA7B,EAAkC;AAChC,EAAF,OAAS,GAAT,CAAa,KAAb,EAAoB,GAApB,CAAwB,KAAxB,EAA+B,GAAG,CAAC,CAAnC,CAAA;AACA,CAAA;AACA,SAAS,QAAT,CAAkB,KAAlB,EAAyB,KAAzB,EAAgC;AAC9B,EAAF,OAAS,OAAO,KAAhB,KAA0B,UAA1B,GAAuC,KAAvC,CAA6C,KAAK,CAAlD,GAAsD,KAAtD,CAAA;AACA,CAAA;AACA,SAAS,OAAT,CAAiB,SAAjB,EAA4B;AAC1B,EAAF,OAAS,SAAT,CAAmB,KAAnB,CAAyB,GAAG,CAA5B,CAA8B,CAAC,CAA/B,CAAA;AACA,CAAA;AACA,SAAS,YAAT,CAAsB,SAAtB,EAAiC;AAC/B,EAAF,OAAS,SAAT,CAAmB,KAAnB,CAAyB,GAAG,CAA5B,CAA8B,CAAC,CAA/B,CAAA;AACA,CAAA;AACA,SAAS,eAAT,CAAyB,IAAzB,EAA+B;AAC7B,EAAF,OAAS,IAAT,KAAkB,GAAlB,GAAwB,GAAxB,GAA8B,GAA9B,CAAA;AACA,CAAA;AACA,SAAS,aAAT,CAAuB,IAAvB,EAA6B;AAC3B,EAAF,OAAS,IAAT,KAAkB,GAAlB,GAAwB,QAAxB,GAAmC,OAAnC,CAAA;AACA,CAAA;AACA,SAAS,WAAT,CAAqB,SAArB,EAAgC;AAC9B,EAAF,OAAS,CAAC,KAAV,EAAiB,QAAQ,CAAzB,CAA2B,QAA3B,CAAoC,OAApC,CAA4C,SAAS,CAAC,CAAtD,GAA0D,GAA1D,GAAgE,GAAhE,CAAA;AACA,CAAA;AACA,SAAS,gBAAT,CAA0B,SAA1B,EAAqC;AACnC,EAAF,OAAS,eAAT,CAAyB,WAAzB,CAAqC,SAAS,CAAC,CAA/C,CAAA;AACA,CAAA;AACA,SAAS,iBAAT,CAA2B,SAA3B,EAAsC,KAAtC,EAA6C,GAA7C,EAAkD;AAChD,EAAF,IAAM,GAAN,KAAc,KAAd,CAAA,EAAsB;AAClB,IAAJ,GAAA,GAAU,KAAV,CAAA;AAAU,GAAV;AAEE,EAAF,MAAQ,SAAR,GAAoB,YAApB,CAAiC,SAAS,CAA1C,CAAA;AACE,EAAF,MAAQ,aAAR,GAAwB,gBAAxB,CAAyC,SAAS,CAAlD,CAAA;AACE,EAAF,MAAQ,MAAR,GAAiB,aAAjB,CAA+B,aAAa,CAA5C,CAAA;AACE,EAAF,IAAM,iBAAN,GAA0B,aAA1B,KAA4C,GAA5C,GAAkD,SAAlD,MAAiE,GAAjE,GAAuE,KAAvE,GAA+E,OAA/E,CAAA,GAA0F,OAA1F,GAAoG,MAApG,GAA6G,SAA7G,KAA2H,OAA3H,GAAqI,QAArI,GAAgJ,KAAhJ,CAAA;AACE,EAAF,IAAM,KAAN,CAAY,SAAZ,CAAsB,MAAM,CAA5B,GAAgC,KAAhC,CAAsC,QAAtC,CAA+C,MAAM,CAArD,EAAwD;AACpD,IAAJ,iBAAA,GAAwB,oBAAxB,CAA6C,iBAAiB,CAA9D,CAAA;AAA8D,GAA9D;AAEE,EAAF,OAAS,CAAC,iBAAV,EAA6B,oBAA7B,CAAkD,iBAAiB,CAAC,CAApE,CAAA;AACA,CAAA;AACA,SAAS,qBAAT,CAA+B,SAA/B,EAA0C;AACxC,EAAF,MAAQ,iBAAR,GAA4B,oBAA5B,CAAiD,SAAS,CAA1D,CAAA;AACE,EAAF,OAAS,CAAC,6BAAV,CAAwC,SAAS,CAAjD,EAAoD,iBAApD,EAAuE,6BAAvE,CAAqG,iBAAiB,CAAC,CAAvH,CAAA;AACA,CAAA;AACA,SAAS,6BAAT,CAAuC,SAAvC,EAAkD;AAChD,EAAF,OAAS,SAAT,CAAmB,OAAnB,CAA2B,YAA3B,EAAyC,CAAzC,SAAA,KAAsD,oBAAtD,CAA2E,SAAS,CAAC,CAArF,CAAA;AACA,CAAA;AACA,SAAS,WAAT,CAAqB,IAArB,EAA2B,OAA3B,EAAoC,GAApC,EAAyC;AACvC,EAAF,MAAQ,EAAR,GAAa,CAAC,MAAd,EAAsB,OAAO,CAA7B,CAAA;AACE,EAAF,MAAQ,EAAR,GAAa,CAAC,OAAd,EAAuB,MAAM,CAA7B,CAAA;AACE,EAAF,MAAQ,EAAR,GAAa,CAAC,KAAd,EAAqB,QAAQ,CAA7B,CAAA;AACE,EAAF,MAAQ,EAAR,GAAa,CAAC,QAAd,EAAwB,KAAK,CAA7B,CAAA;AACE,EAAF,QAAU,IAAV;AAAc,IACV,KAAK,KADT,CAAA;AACS,IACL,KAAK,QADT;AAEM,MAAN,IAAU,GAAV;AAAe,QAAf,OAAsB,OAAtB,GAAgC,EAAhC,GAAqC,EAArC,CAAA;AACM,MAAN,OAAa,OAAb,GAAuB,EAAvB,GAA4B,EAA5B,CAAA;AAA4B,IACxB,KAAK,MADT,CAAA;AACS,IACL,KAAK,OADT;AAEM,MAAN,OAAa,OAAb,GAAuB,EAAvB,GAA4B,EAA5B,CAAA;AAA4B,IACxB;AACE,MAAN,OAAa,EAAb,CAAA;AACA,GAAA;AACA,CAAA;AACA,SAAS,yBAAT,CAAmC,SAAnC,EAA8C,aAA9C,EAA6D,SAA7D,EAAwE,GAAxE,EAA6E;AAC3E,EAAF,MAAQ,SAAR,GAAoB,YAApB,CAAiC,SAAS,CAA1C,CAAA;AACE,EAAF,IAAM,IAAN,GAAa,WAAb,CAAyB,OAAzB,CAAiC,SAAS,CAA1C,EAA6C,SAA7C,KAA2D,OAA3D,EAAoE,GAAG,CAAvE,CAAA;AACE,EAAF,IAAM,SAAN,EAAiB;AACb,IAAJ,IAAA,GAAW,IAAX,CAAgB,GAAhB,CAAoB,CAApB,IAAA,KAA4B,IAA5B,GAAmC,GAAnC,GAAyC,SAAS,CAAlD,CAAA;AACI,IAAJ,IAAQ,aAAR,EAAuB;AACjB,MAAN,IAAA,GAAa,IAAb,CAAkB,MAAlB,CAAyB,IAAzB,CAA8B,GAA9B,CAAkC,6BAA6B,CAAC,CAAhE,CAAA;AAAgE,KAAhE;AACK,GAAL;AAEE,EAAF,OAAS,IAAT,CAAA;AACA,CAAA;AACA,SAAS,oBAAT,CAA8B,SAA9B,EAAyC;AACvC,EAAF,OAAS,SAAT,CAAmB,OAAnB,CAA2B,wBAA3B,EAAqD,CAArD,IAAA,KAA6D,eAA7D,CAA6E,IAAI,CAAC,CAAlF,CAAA;AACA,CAAA;AACA,SAAS,mBAAT,CAA6B,OAA7B,EAAsC;AACpC,EAAF,OAAS;AAAA,IACL,GADJ,EACS,CADT;AACS,IACL,KADJ,EACW,CADX;AACW,IACP,MADJ,EACY,CADZ;AACY,IACR,IADJ,EACU,CADV;AACU,IACN,GAAG,OADP;AACO,GAAP,CAAA;AAEA,CAAA;AACA,SAAS,gBAAT,CAA0B,OAA1B,EAAmC;AACjC,EAAF,OAAS,OAAO,OAAhB,KAA4B,QAA5B,GAAuC,mBAAvC,CAA2D,OAAO,CAAlE,GAAsE;AAAA,IAClE,GADJ,EACS,OADT;AACS,IACL,KADJ,EACW,OADX;AACW,IACP,MADJ,EACY,OADZ;AACY,IACR,IADJ,EACU,OADV;AACU,GAAV,CAAA;AAEA,CAAA;AACA,SAAS,gBAAT,CAA0B,IAA1B,EAAgC;AAC9B,EAAF,OAAS;AAAA,IACL,GAAG,IADP;AACO,IACH,GADJ,EACS,IADT,CACc,CADd;AACc,IACV,IADJ,EACU,IADV,CACe,CADf;AACe,IACX,KADJ,EACW,IADX,CACgB,CADhB,GACoB,IADpB,CACyB,KADzB;AACyB,IACrB,MADJ,EACY,IADZ,CACiB,CADjB,GACqB,IADrB,CAC0B,MAD1B;AAC0B,GAA1B,CAAA;AAEA,CAAA;AD3HA,SAAS,0BAAT,CAAoC,IAApC,EAA0C,SAA1C,EAAqD,GAArD,EAA0D;AACxD,EAAF,IAAM;AAAA,IACF,SADJ;AACI,IACA,QADJ;AACI,GAAJ,GACM,IADN,CAAA;AAEE,EAAF,MAAQ,QAAR,GAAmB,WAAnB,CAA+B,SAAS,CAAxC,CAAA;AACE,EAAF,MAAQ,aAAR,GAAwB,gBAAxB,CAAyC,SAAS,CAAlD,CAAA;AACE,EAAF,MAAQ,WAAR,GAAsB,aAAtB,CAAoC,aAAa,CAAjD,CAAA;AACE,EAAF,MAAQ,IAAR,GAAe,OAAf,CAAuB,SAAS,CAAhC,CAAA;AACE,EAAF,MAAQ,UAAR,GAAqB,QAArB,KAAkC,GAAlC,CAAA;AACE,EAAF,MAAQ,OAAR,GAAkB,SAAlB,CAA4B,CAA5B,GAAgC,SAAhC,CAA0C,KAA1C,GAAkD,CAAlD,GAAsD,QAAtD,CAA+D,KAA/D,GAAuE,CAAvE,CAAA;AACE,EAAF,MAAQ,OAAR,GAAkB,SAAlB,CAA4B,CAA5B,GAAgC,SAAhC,CAA0C,MAA1C,GAAmD,CAAnD,GAAuD,QAAvD,CAAgE,MAAhE,GAAyE,CAAzE,CAAA;AACE,EAAF,MAAQ,WAAR,GAAsB,SAAtB,CAAgC,WAAW,CAA3C,GAA+C,CAA/C,GAAmD,QAAnD,CAA4D,WAAW,CAAvE,GAA2E,CAA3E,CAAA;AACE,EAAF,IAAM,MAAN,CAAA;AACE,EAAF,QAAU,IAAV;AAAc,IACV,KAAK,KADT;AAEM,MAAN,MAAA,GAAe;AAAA,QACP,CADR,EACW,OADX;AACW,QACH,CADR,EACW,SADX,CACqB,CADrB,GACyB,QADzB,CACkC,MADlC;AACkC,OAAlC,CAAA;AAEM,MAAN,MAAA;AAAM,IACF,KAAK,QADT;AAEM,MAAN,MAAA,GAAe;AAAA,QACP,CADR,EACW,OADX;AACW,QACH,CADR,EACW,SADX,CACqB,CADrB,GACyB,SADzB,CACmC,MADnC;AACmC,OAAnC,CAAA;AAEM,MAAN,MAAA;AAAM,IACF,KAAK,OADT;AAEM,MAAN,MAAA,GAAe;AAAA,QACP,CADR,EACW,SADX,CACqB,CADrB,GACyB,SADzB,CACmC,KADnC;AACmC,QAC3B,CADR,EACW,OADX;AACW,OAAX,CAAA;AAEM,MAAN,MAAA;AAAM,IACF,KAAK,MADT;AAEM,MAAN,MAAA,GAAe;AAAA,QACP,CADR,EACW,SADX,CACqB,CADrB,GACyB,QADzB,CACkC,KADlC;AACkC,QAC1B,CADR,EACW,OADX;AACW,OAAX,CAAA;AAEM,MAAN,MAAA;AAAM,IACF;AACE,MAAN,MAAA,GAAe;AAAA,QACP,CADR,EACW,SADX,CACqB,CADrB;AACqB,QACb,CADR,EACW,SADX,CACqB,CADrB;AACqB,OAArB,CAAA;AACA,GAAA;AAEE,EAAF,QAAU,YAAV,CAAuB,SAAS,CAAhC;AAAiC,IAC7B,KAAK,OADT;AAEM,MAAN,MAAA,CAAa,aAAa,CAA1B,IAA+B,WAA/B,IAA8C,GAA9C,IAAqD,UAArD,GAAkE,CAAlE,CAAA,GAAuE,CAAvE,CAAA,CAAA;AACM,MAAN,MAAA;AAAM,IACF,KAAK,KADT;AAEM,MAAN,MAAA,CAAa,aAAa,CAA1B,IAA+B,WAA/B,IAA8C,GAA9C,IAAqD,UAArD,GAAkE,CAAlE,CAAA,GAAuE,CAAvE,CAAA,CAAA;AACM,MAAN,MAAA;AAAM,GAAN;AAEE,EAAF,OAAS,MAAT,CAAA;AACA,CAAA;AASA,MAAMoB,iBAAN,GAAwB,OAAO,SAA/B,EAA0C,QAA1C,EAAoD,MAApD,KAA+D;AAC7D,EAAF,MAAQ;AAAA,IACJ,SADJ,GACgB,QADhB;AACgB,IACZ,QADJ,GACe,UADf;AACe,IACX,UADJ,GACiB,EADjB;AACmB,IACf,QADJ,EACIJ,SADJ;AACI,GAAJ,GACM,MADN,CAAA;AAEE,EAAF,MAAQ,eAAR,GAA0B,UAA1B,CAAqC,MAArC,CAA4C,OAAO,CAAnD,CAAA;AACE,EAAF,MAAQ,GAAR,GAAc,OAAOA,SAArB,CAA8B,KAA9B,IAAuC,IAAvC,GAA8C,KAA9C,CAAA,GAAuDA,SAAvD,CAAgE,KAAhE,CAAsE,QAAQ,CAA9E,CAAA,CAAA;AACE,EAAF,IAAM,KAAN,GAAc,MAAMA,SAApB,CAA6B,eAA7B,CAA6C;AAAA,IACzC,SADJ;AACI,IACA,QADJ;AACI,IACA,QADJ;AACI,GACD,CADH,CAAA;AAEE,EAAF,IAAM;AAAA,IACF,CADJ;AACI,IACA,CADJ;AACI,GAAJ,GACM,0BADN,CACiC,KADjC,EACwC,SADxC,EACmD,GAAG,CADtD,CAAA;AAEE,EAAF,IAAM,iBAAN,GAA0B,SAA1B,CAAA;AACE,EAAF,IAAM,cAAN,GAAuB,EAAvB,CAAA;AACE,EAAF,IAAM,UAAN,GAAmB,CAAnB,CAAA;AACE,EAAF,KAAA,IAAW,CAAX,GAAe,CAAf,EAAkB,CAAlB,GAAsB,eAAtB,CAAsC,MAAtC,EAA8C,CAA9C,EAAA,EAAmD;AAC/C,IAAJ,MAAU;AAAA,MACJ,IADN;AACM,MACA,EADN;AACM,KAAN,GACQ,eADR,CACwB,CAAC,CADzB,CAAA;AAEI,IAAJ,MAAU;AAAA,MACJ,CADN,EACS,KADT;AACS,MACH,CADN,EACS,KADT;AACS,MACH,IADN;AACM,MACA,KADN;AACM,KAAN,GACQ,MAAM,EADd,CACiB;AAAA,MACX,CADN;AACM,MACA,CADN;AACM,MACA,gBADN,EACwB,SADxB;AACwB,MAClB,SADN,EACiB,iBADjB;AACiB,MACX,QADN;AACM,MACA,cADN;AACM,MACA,KADN;AACM,MACA,QADN,EACMA,SADN;AACM,MACA,QADN,EACgB;AAAA,QACR,SADR;AACQ,QACA,QADR;AACQ,OAAR;AACO,KACF,CADL,CAAA;AAEI,IAAJ,CAAA,GAAQ,KAAR,IAAiB,IAAjB,GAAwB,KAAxB,GAAgC,CAAhC,CAAA;AACI,IAAJ,CAAA,GAAQ,KAAR,IAAiB,IAAjB,GAAwB,KAAxB,GAAgC,CAAhC,CAAA;AACI,IAAJ,cAAA,GAAqB;AAAA,MACf,GAAG,cADT;AACS,MACH,CAAC,IAAI,GAAG;AAAA,QACN,GAAG,cADX,CAC0B,IAAI,CAD9B;AAC8B,QACtB,GAAG,IADX;AACW,OAAX;AACO,KAAP,CAAA;AAEI,IAAJ,IAAQ,KAAR,IAAiB,UAAjB,IAA+B,EAA/B,EAAmC;AAC7B,MAAN,UAAA,EAAA,CAAA;AACM,MAAN,IAAU,OAAO,KAAjB,KAA2B,QAA3B,EAAqC;AAC7B,QAAR,IAAY,KAAZ,CAAkB,SAAlB,EAA6B;AACnB,UAAV,iBAAA,GAA8B,KAA9B,CAAoC,SAApC,CAAA;AAAoC,SAApC;AAEQ,QAAR,IAAY,KAAZ,CAAkB,KAAlB,EAAyB;AACf,UAAV,KAAA,GAAkB,KAAlB,CAAwB,KAAxB,KAAkC,IAAlC,GAAyC,MAAMA,SAA/C,CAAwD,eAAxD,CAAwE;AAAA,YAC5D,SADZ;AACY,YACA,QADZ;AACY,YACA,QADZ;AACY,WACD,CADX,GACe,KADf,CACqB,KADrB,CAAA;AACqB,SAArB;AAEQ,QAAR,CAAS;AAAA,UACC,CADV;AACU,UACA,CADV;AACU,SAAV,GACY,0BADZ,CACuC,KADvC,EAC8C,iBAD9C,EACiE,GAAG,CADpE,EAAA;AACoE,OAApE;AAEM,MAAN,CAAA,GAAU,CAAV,CAAA,CAAA;AACM,MAAN,SAAA;AAAM,KAAN;AACK,GAAL;AAEE,EAAF,OAAS;AAAA,IACL,CADJ;AACI,IACA,CADJ;AACI,IACA,SADJ,EACe,iBADf;AACe,IACX,QADJ;AACI,IACA,cADJ;AACI,GAAJ,CAAA;AAEA,CAAA,CAAA;AAUA,eAAe,cAAf,CAA8B,KAA9B,EAAqC,OAArC,EAA8C;AAC5C,EAAF,IAAM,qBAAN,CAAA;AACE,EAAF,IAAM,OAAN,KAAkB,KAAlB,CAAA,EAA0B;AACtB,IAAJ,OAAA,GAAc,EAAd,CAAA;AAAc,GAAd;AAEE,EAAF,MAAQ;AAAA,IACJ,CADJ;AACI,IACA,CADJ;AACI,IACA,QADJ,EACIA,SADJ;AACI,IACA,KADJ;AACI,IACA,QADJ;AACI,IACA,QADJ;AACI,GAAJ,GACM,KADN,CAAA;AAEE,EAAF,MAAQ;AAAA,IACJ,QADJ,GACe,mBADf;AACe,IACX,YADJ,GACmB,UADnB;AACmB,IACf,cADJ,GACqB,UADrB;AACqB,IACjB,WADJ,GACkB,KADlB;AACkB,IACd,OADJ,GACc,CADd;AACc,GAAd,GACM,QADN,CACe,OADf,EACwB,KAAK,CAD7B,CAAA;AAEE,EAAF,MAAQ,aAAR,GAAwB,gBAAxB,CAAyC,OAAO,CAAhD,CAAA;AACE,EAAF,MAAQ,UAAR,GAAqB,cAArB,KAAwC,UAAxC,GAAqD,WAArD,GAAmE,UAAnE,CAAA;AACE,EAAF,MAAQ,OAAR,GAAkB,QAAlB,CAA2B,WAA3B,GAAyC,UAAzC,GAAsD,cAAc,CAApE,CAAA;AACE,EAAF,MAAQ,kBAAR,GAA6B,gBAA7B,CAA8C,MAAMA,SAApD,CAA6D,eAA7D,CAA6E;AAAA,IACzE,OADJ,EAAA,CAAA,CACe,qBADf,GACuC,OAAOA,SAD9C,CACuD,SADvD,IACoE,IADpE,GAC2E,KAD3E,CAAA,GACoFA,SADpF,CAC6F,SAD7F,CACuG,OAAO,CAD9G,CAAA,KACqH,IADrH,GAC4H,qBAD5H,GACoJ,IADpJ,IAC4J,OAD5J,GACsK,OADtK,CAC8K,cAD9K,IACiM,OAAOA,SADxM,CACiN,kBADjN,IACuO,IADvO,GAC8O,KAD9O,CAAA,GACuPA,SADvP,CACgQ,kBADhQ,CACmR,QADnR,CAC4R,QAAQ,CADpS,CAAA;AACoS,IAChS,QADJ;AACI,IACA,YADJ;AACI,IACA,QADJ;AACI,GACD,CAAC,CADJ,CAAA;AAEE,EAAF,MAAQ,IAAR,GAAe,cAAf,KAAkC,UAAlC,GAA+C;AAAA,IAC3C,GAAG,KADP,CACa,QADb;AACa,IACT,CADJ;AACI,IACA,CADJ;AACI,GAAJ,GACM,KADN,CACY,SADZ,CAAA;AAEE,EAAF,MAAQ,YAAR,GAAuB,OAAOA,SAA9B,CAAuC,eAAvC,IAA0D,IAA1D,GAAiE,KAAjE,CAAA,GAA0EA,SAA1E,CAAmF,eAAnF,CAAmG,QAAnG,CAA4G,QAAQ,CAApH,CAAA,CAAA;AACE,EAAF,MAAQ,WAAR,GAAuB,OAAOA,SAA9B,CAAuC,SAAvC,IAAoD,IAApD,GAA2D,KAA3D,CAAA,GAAoEA,SAApE,CAA6E,SAA7E,CAAuF,YAAY,CAAnG,CAAA,GAA0G,OAAOA,SAAjH,CAA0H,QAA1H,IAAsI,IAAtI,GAA6I,KAA7I,CAAA,GAAsJA,SAAtJ,CAA+J,QAA/J,CAAwK,YAAY,CAApL,CAAA,IAA2L;AAAA,IACvL,CADJ,EACO,CADP;AACO,IACH,CADJ,EACO,CADP;AACO,GAAP,GACM;AAAA,IACF,CADJ,EACO,CADP;AACO,IACH,CADJ,EACO,CADP;AACO,GAAP,CAAA;AAEE,EAAF,MAAQ,iBAAR,GAA4B,gBAA5B,CAA6CA,SAA7C,CAAsD,qDAAtD,GAA8G,MAAMA,SAApH,CAA6H,qDAA7H,CAAmL;AAAA,IAC/K,IADJ;AACI,IACA,YADJ;AACI,IACA,QADJ;AACI,GACD,CADH,GACO,IAAI,CADX,CAAA;AAEE,EAAF,OAAS;AAAA,IACL,GADJ,EAAA,CACU,kBADV,CAC6B,GAD7B,GACmC,iBADnC,CACqD,GADrD,GAC2D,aAD3D,CACyE,GADzE,IACgF,WADhF,CAC4F,CAD5F;AAC4F,IACxF,MADJ,EAAA,CACa,iBADb,CAC+B,MAD/B,GACwC,kBADxC,CAC2D,MAD3D,GACoE,aADpE,CACkF,MADlF,IAC4F,WAD5F,CACwG,CADxG;AACwG,IACpG,IADJ,EAAA,CACW,kBADX,CAC8B,IAD9B,GACqC,iBADrC,CACuD,IADvD,GAC8D,aAD9D,CAC4E,IAD5E,IACoF,WADpF,CACgG,CADhG;AACgG,IAC5F,KADJ,EAAA,CACY,iBADZ,CAC8B,KAD9B,GACsC,kBADtC,CACyD,KADzD,GACiE,aADjE,CAC+E,KAD/E,IACwF,WADxF,CACoG,CADpG;AACoG,GAApG,CAAA;AAEA,CAAA;AAiMA,MAAMG,MAAN,GAAa,SAAU,OAAvB,EAAgC;AAC9B,EAAF,IAAM,OAAN,KAAkB,KAAlB,CAAA,EAA0B;AACtB,IAAJ,OAAA,GAAc,EAAd,CAAA;AAAc,GAAd;AAEE,EAAF,OAAS;AAAA,IACL,IADJ,EACU,MADV;AACU,IACN,OADJ;AACI,IACA,MAAM,EADV,CACa,KADb,EACoB;AACd,MAAN,IAAU,qBAAV,EAAiC,oBAAjC,CAAA;AACM,MAAN,MAAY;AAAA,QACJ,SADR;AACQ,QACA,cADR;AACQ,QACA,KADR;AACQ,QACA,gBADR;AACQ,QACA,QADR,EACQH,SADR;AACQ,QACA,QADR;AACQ,OAAR,GACU,KADV,CAAA;AAEM,MAAN,MAAY;AAAA,QACJ,QADR,EACkB,aADlB,GACkC,IADlC;AACkC,QAC1B,SADR,EACmB,cADnB,GACoC,IADpC;AACoC,QAC5B,kBADR,EAC4B,2BAD5B;AAC4B,QACpB,gBADR,GAC2B,SAD3B;AAC2B,QACnB,yBADR,GACoC,MADpC;AACoC,QAC5B,aADR,GACwB,IADxB;AACwB,QAChB,GAAG,qBADX;AACW,OAAX,GACU,QADV,CACmB,OADnB,EAC4B,KAAK,CADjC,CAAA;AAOM,MAAN,IAAA,CAAW,qBAAX,GAAmC,cAAnC,CAAkD,KAAlD,KAA4D,IAA5D,IAAoE,qBAApE,CAA0F,eAA1F,EAA2G;AACnG,QAAR,OAAe,EAAf,CAAA;AACA,OAAA;AACM,MAAN,MAAY,IAAZ,GAAmB,OAAnB,CAA2B,SAAS,CAApC,CAAA;AACM,MAAN,MAAY,eAAZ,GAA8B,OAA9B,CAAsC,gBAAgB,CAAtD,KAA4D,gBAA5D,CAAA;AACM,MAAN,MAAY,GAAZ,GAAkB,OAAOA,SAAzB,CAAkC,KAAlC,IAA2C,IAA3C,GAAkD,KAAlD,CAAA,GAA2DA,SAA3D,CAAoE,KAApE,CAA0E,QAA1E,CAAmF,QAAQ,CAA3F,CAAA,CAAA;AACM,MAAN,MAAY,kBAAZ,GAAiC,2BAAjC,KAAiE,eAAjE,IAAoF,CAAC,aAArF,GAAqG,CAAC,oBAAtG,CAA2H,gBAAgB,CAAC,CAA5I,GAAgJ,qBAAhJ,CAAsK,gBAAgB,CAAtL,CAAA,CAAA;AACM,MAAN,IAAU,CAAC,2BAAX,IAA0C,yBAA1C,KAAwE,MAAxE,EAAgF;AACxE,QAAR,kBAAA,CAA2B,IAA3B,CAAgC,GAAG,yBAAnC,CAA6D,gBAA7D,EAA+E,aAA/E,EAA8F,yBAA9F,EAAyH,GAAG,CAAC,CAA7H,CAAA;AAA6H,OAA7H;AAEM,MAAN,MAAY,UAAZ,GAAyB,CAAC,gBAA1B,EAA4C,GAAG,kBAAkB,CAAjE,CAAA;AACM,MAAN,MAAY,QAAZ,GAAuB,MAAM,cAA7B,CAA4C,KAA5C,EAAmD,qBAAqB,CAAxE,CAAA;AACM,MAAN,MAAY,SAAZ,GAAwB,EAAxB,CAAA;AACM,MAAN,IAAU,aAAV,GAAA,CAAA,CAA4B,oBAA5B,GAAmD,cAAnD,CAAkE,IAAlE,KAA2E,IAA3E,GAAkF,KAAlF,CAAA,GAA2F,oBAA3F,CAAgH,SAAhH,KAA8H,EAA9H,CAAA;AACM,MAAN,IAAU,aAAV,EAAyB;AACjB,QAAR,SAAA,CAAkB,IAAlB,CAAuB,QAAvB,CAAgC,IAAI,CAAC,CAArC,CAAA;AAAqC,OAArC;AAEM,MAAN,IAAU,cAAV,EAA0B;AAClB,QAAR,MAAc,KAAd,GAAsB,iBAAtB,CAAwC,SAAxC,EAAmD,KAAnD,EAA0D,GAAG,CAA7D,CAAA;AACQ,QAAR,SAAA,CAAkB,IAAlB,CAAuB,QAAvB,CAAgC,KAAhC,CAAsC,CAAC,CAAC,CAAxC,EAA2C,QAA3C,CAAoD,KAApD,CAA0D,CAAC,CAAC,CAAC,CAA7D,CAAA;AAA6D,OAA7D;AAEM,MAAN,aAAA,GAAsB,CAAC,GAAG,aAA1B,EAAyC;AAAA,QACjC,SADR;AACQ,QACA,SADR;AACQ,OACD,CADP,CAAA;AAIM,MAAN,IAAU,CAAC,SAAX,CAAqB,KAArB,CAA2B,CAAAE,KAA3B,KAAmCA,KAAnC,IAA2C,CAAC,CAA5C,EAA+C;AACvC,QAAR,IAAY,qBAAZ,EAAmC,qBAAnC,CAAA;AACQ,QAAR,MAAc,SAAd,GAAA,CAAA,CAAA,CAA6B,qBAA7B,GAAqD,cAArD,CAAoE,IAApE,KAA6E,IAA7E,GAAoF,KAApF,CAAA,GAA6F,qBAA7F,CAAmH,KAAnH,KAA6H,CAA7H,IAAkI,CAAlI,CAAA;AACQ,QAAR,MAAc,aAAd,GAA8B,UAA9B,CAAyC,SAAS,CAAlD,CAAA;AACQ,QAAR,IAAY,aAAZ,EAA2B;AAEjB,UAAV,OAAiB;AAAA,YACL,IADZ,EACkB;AAAA,cACJ,KADd,EACqB,SADrB;AACqB,cACP,SADd,EACyB,aADzB;AACyB,aAAzB;AACa,YACD,KADZ,EACmB;AAAA,cACL,SADd,EACyB,aADzB;AACyB,aAAzB;AACa,WAAb,CAAA;AACA,SAAA;AAKQ,QAAR,IAAY,cAAZ,GAAA,CAA8B,qBAA9B,GAAsD,aAAtD,CAAoE,MAApE,CAA2E,CAA3E,CAAA,KAAgF,CAAhF,CAAkF,SAAlF,CAA4F,CAAC,CAA7F,IAAkG,CAAC,CAAnG,CAAqG,IAArG,CAA0G,CAAC,CAA3G,EAA8G,CAA9G,KAAoH,CAApH,CAAsH,SAAtH,CAAgI,CAAC,CAAjI,GAAqI,CAArI,CAAuI,SAAvI,CAAiJ,CAAC,CAAC,CAAnJ,CAAqJ,CAAC,CAAtJ,KAA4J,IAA5J,GAAmK,KAAnK,CAAA,GAA4K,qBAA5K,CAAkM,SAAlM,CAAA;AAGQ,QAAR,IAAY,CAAC,cAAb,EAA6B;AACnB,UAAV,QAAkB,gBAAlB;AAAkC,YACtB,KAAK,SADjB,EAEc;AACE,cAAhB,IAAoB,qBAApB,CAAA;AACgB,cAAhB,MAAsBb,UAAtB,GAAA,CAAmC,qBAAnC,GAA2D,aAA3D,CAAyE,GAAzE,CAA6E,CAA7E,CAAA,KAAkF,CAAC,CAAnF,CAAqF,SAArF,EAAgG,CAAhG,CAAkG,SAAlG,CAA4G,MAA5G,CAAmH,CAAAY,SAAnH,KAA+HA,SAA/H,GAA0I,CAAC,CAA3I,CAA6I,MAA7I,CAAoJ,CAAC,GAArJ,EAA0JA,SAA1J,KAAuK,GAAvK,GAA6KA,SAA7K,EAAuL,CAAC,CAAC,CAAC,CAA1L,CAA4L,IAA5L,CAAiM,CAAC,CAAlM,EAAqM,CAArM,KAA2M,CAA3M,CAA6M,CAAC,CAA9M,GAAkN,CAAlN,CAAoN,CAAC,CAAC,CAAtN,CAAwN,CAAC,CAAzN,KAA+N,IAA/N,GAAsO,KAAtO,CAAA,GAA+O,qBAA/O,CAAqQ,CAAC,CAAtQ,CAAA;AACgB,cAAhB,IAAoBZ,UAApB,EAA+B;AACb,gBAAlB,cAAA,GAAmCA,UAAnC,CAAA;AAAmC,eAAnC;AAEgB,cAAhB,MAAA;AAAgB,aAAhB;AACe,YACH,KAAK,kBADjB;AAEc,cAAd,cAAA,GAA+B,gBAA/B,CAAA;AACc,cAAd,MAAA;AAAc,WAAd;AACW,SAAX;AAEQ,QAAR,IAAY,SAAZ,KAA0B,cAA1B,EAA0C;AAChC,UAAV,OAAiB;AAAA,YACL,KADZ,EACmB;AAAA,cACL,SADd,EACyB,cADzB;AACyB,aAAzB;AACa,WAAb,CAAA;AACA,SAAA;AACS,OAAT;AAEM,MAAN,OAAa,EAAb,CAAA;AACA,KAAA;AAAK,GAAL,CAAA;AAEA,CAAA,CAAA;AA6MA,eAAe,oBAAf,CAAoC,KAApC,EAA2C,OAA3C,EAAoD;AAClD,EAAF,MAAQ;AAAA,IACJ,SADJ;AACI,IACA,QADJ,EACIW,SADJ;AACI,IACA,QADJ;AACI,GAAJ,GACM,KADN,CAAA;AAEE,EAAF,MAAQ,GAAR,GAAc,OAAOA,SAArB,CAA8B,KAA9B,IAAuC,IAAvC,GAA8C,KAA9C,CAAA,GAAuDA,SAAvD,CAAgE,KAAhE,CAAsE,QAAtE,CAA+E,QAAQ,CAAvF,CAAA,CAAA;AACE,EAAF,MAAQ,IAAR,GAAe,OAAf,CAAuB,SAAS,CAAhC,CAAA;AACE,EAAF,MAAQ,SAAR,GAAoB,YAApB,CAAiC,SAAS,CAA1C,CAAA;AACE,EAAF,MAAQ,UAAR,GAAqB,WAArB,CAAiC,SAAS,CAA1C,KAAgD,GAAhD,CAAA;AACE,EAAF,MAAQ,aAAR,GAAwB,CAAC,MAAzB,EAAiC,KAAK,CAAtC,CAAwC,QAAxC,CAAiD,IAAI,CAArD,GAAyD,CAAzD,CAAA,GAA8D,CAA9D,CAAA;AACE,EAAF,MAAQ,cAAR,GAAyB,GAAzB,IAAgC,UAAhC,GAA6C,CAA7C,CAAA,GAAkD,CAAlD,CAAA;AACE,EAAF,MAAQ,QAAR,GAAmB,QAAnB,CAA4B,OAA5B,EAAqC,KAAK,CAA1C,CAAA;AAGE,EAAF,IAAM;AAAA,IACF,QADJ;AACI,IACA,SADJ;AACI,IACA,aADJ;AACI,GAAJ,GACM,OAAO,QADb,KAC0B,QAD1B,GACqC;AAAA,IACjC,QADJ,EACc,QADd;AACc,IACV,SADJ,EACe,CADf;AACe,IACX,aADJ,EACmB,IADnB;AACmB,GAAnB,GACM;AAAA,IACF,QADJ,EACc,CADd;AACc,IACV,SADJ,EACe,CADf;AACe,IACX,aADJ,EACmB,IADnB;AACmB,IACf,GAAG,QADP;AACO,GAAP,CAAA;AAEE,EAAF,IAAM,SAAN,IAAmB,OAAO,aAA1B,KAA4C,QAA5C,EAAsD;AAClD,IAAJ,SAAA,GAAgB,SAAhB,KAA8B,KAA9B,GAAsC,aAAtC,GAAsD,CAAtD,CAAA,GAA2D,aAA3D,CAAA;AAA2D,GAA3D;AAEE,EAAF,OAAS,UAAT,GAAsB;AAAA,IAClB,CADJ,EACO,SADP,GACmB,cADnB;AACmB,IACf,CADJ,EACO,QADP,GACkB,aADlB;AACkB,GAAlB,GACM;AAAA,IACF,CADJ,EACO,QADP,GACkB,aADlB;AACkB,IACd,CADJ,EACO,SADP,GACmB,cADnB;AACmB,GAAnB,CAAA;AAEA,CAAA;AASA,MAAM,MAAN,GAAe,SAAU,OAAzB,EAAkC;AAChC,EAAF,IAAM,OAAN,KAAkB,KAAlB,CAAA,EAA0B;AACtB,IAAJ,OAAA,GAAc,CAAd,CAAA;AAAc,GAAd;AAEE,EAAF,OAAS;AAAA,IACL,IADJ,EACU,QADV;AACU,IACN,OADJ;AACI,IACA,MAAM,EADV,CACa,KADb,EACoB;AACd,MAAN,IAAU,qBAAV,EAAiC,qBAAjC,CAAA;AACM,MAAN,MAAY;AAAA,QACJ,CADR;AACQ,QACA,CADR;AACQ,QACA,SADR;AACQ,QACA,cADR;AACQ,OAAR,GACU,KADV,CAAA;AAEM,MAAN,MAAY,UAAZ,GAAyB,MAAM,oBAA/B,CAAoD,KAApD,EAA2D,OAAO,CAAlE,CAAA;AAIM,MAAN,IAAU,SAAV,MAAA,CAA0B,qBAA1B,GAAkD,cAAlD,CAAiE,MAAjE,KAA4E,IAA5E,GAAmF,KAAnF,CAAA,GAA4F,qBAA5F,CAAkH,SAAlH,CAAA,IAAA,CAAiI,qBAAjI,GAAyJ,cAAzJ,CAAwK,KAAxK,KAAkL,IAAlL,IAA0L,qBAA1L,CAAgN,eAAhN,EAAiO;AACzN,QAAR,OAAe,EAAf,CAAA;AACA,OAAA;AACM,MAAN,OAAa;AAAA,QACL,CADR,EACW,CADX,GACe,UADf,CAC0B,CAD1B;AAC0B,QAClB,CADR,EACW,CADX,GACe,UADf,CAC0B,CAD1B;AAC0B,QAClB,IADR,EACc;AAAA,UACJ,GAAG,UADb;AACa,UACH,SADV;AACU,SAAV;AACS,OAAT,CAAA;AACA,KAAA;AACK,GAAL,CAAA;AAEA,CAAA,CAAA;AAOA,MAAMD,OAAN,GAAc,SAAU,OAAxB,EAAiC;AAC/B,EAAF,IAAM,OAAN,KAAkB,KAAlB,CAAA,EAA0B;AACtB,IAAJ,OAAA,GAAc,EAAd,CAAA;AAAc,GAAd;AAEE,EAAF,OAAS;AAAA,IACL,IADJ,EACU,OADV;AACU,IACN,OADJ;AACI,IACA,MAAM,EADV,CACa,KADb,EACoB;AACd,MAAN,MAAY;AAAA,QACJ,CADR;AACQ,QACA,CADR;AACQ,QACA,SADR;AACQ,OAAR,GACU,KADV,CAAA;AAEM,MAAN,MAAY;AAAA,QACJ,QADR,EACkB,aADlB,GACkC,IADlC;AACkC,QAC1B,SADR,EACmB,cADnB,GACoC,KADpC;AACoC,QAC5B,OADR,GACkB;AAAA,UACR,EADV,EACc,CADd,IAAA,KACsB;AACV,YAAZ,IAAgB;AAAA,cACF,CADd,EACcD,EADd;AACc,cACA,CADd,EACcD,EADd;AACc,aAAd,GACgB,IADhB,CAAA;AAEY,YAAZ,OAAmB;AAAA,cACL,CADd,EACcC,EADd;AACc,cACA,CADd,EACcD,EADd;AACc,aAAd,CAAA;AACA,WAAA;AACW,SAAX;AACS,QACD,GAAG,qBADX;AACW,OAAX,GACU,QADV,CACmB,OADnB,EAC4B,KAAK,CADjC,CAAA;AAEM,MAAN,MAAY,MAAZ,GAAqB;AAAA,QACb,CADR;AACQ,QACA,CADR;AACQ,OAAR,CAAA;AAEM,MAAN,MAAY,QAAZ,GAAuB,MAAM,cAA7B,CAA4C,KAA5C,EAAmD,qBAAqB,CAAxE,CAAA;AACM,MAAN,MAAY,SAAZ,GAAwB,WAAxB,CAAoC,OAApC,CAA4C,SAAS,CAAC,CAAtD,CAAA;AACM,MAAN,MAAY,QAAZ,GAAuB,eAAvB,CAAuC,SAAS,CAAhD,CAAA;AACM,MAAN,IAAU,aAAV,GAA0B,MAA1B,CAAiC,QAAQ,CAAzC,CAAA;AACM,MAAN,IAAU,cAAV,GAA2B,MAA3B,CAAkC,SAAS,CAA3C,CAAA;AACM,MAAN,IAAU,aAAV,EAAyB;AACjB,QAAR,MAAc,OAAd,GAAwB,QAAxB,KAAqC,GAArC,GAA2C,KAA3C,GAAmD,MAAnD,CAAA;AACQ,QAAR,MAAc,OAAd,GAAwB,QAAxB,KAAqC,GAArC,GAA2C,QAA3C,GAAsD,OAAtD,CAAA;AACQ,QAAR,MAAcF,IAAd,GAAoB,aAApB,GAAoC,QAApC,CAA6C,OAAO,CAApD,CAAA;AACQ,QAAR,MAAcC,IAAd,GAAoB,aAApB,GAAoC,QAApC,CAA6C,OAAO,CAApD,CAAA;AACQ,QAAR,aAAA,GAAwB,KAAxB,CAA8BD,IAA9B,EAAmC,aAAnC,EAAkDC,IAAG,CAArD,CAAA;AAAqD,OAArD;AAEM,MAAN,IAAU,cAAV,EAA0B;AAClB,QAAR,MAAc,OAAd,GAAwB,SAAxB,KAAsC,GAAtC,GAA4C,KAA5C,GAAoD,MAApD,CAAA;AACQ,QAAR,MAAc,OAAd,GAAwB,SAAxB,KAAsC,GAAtC,GAA4C,QAA5C,GAAuD,OAAvD,CAAA;AACQ,QAAR,MAAcD,IAAd,GAAoB,cAApB,GAAqC,QAArC,CAA8C,OAAO,CAArD,CAAA;AACQ,QAAR,MAAcC,IAAd,GAAoB,cAApB,GAAqC,QAArC,CAA8C,OAAO,CAArD,CAAA;AACQ,QAAR,cAAA,GAAyB,KAAzB,CAA+BD,IAA/B,EAAoC,cAApC,EAAoDC,IAAG,CAAvD,CAAA;AAAuD,OAAvD;AAEM,MAAN,MAAY,aAAZ,GAA4B,OAA5B,CAAoC,EAApC,CAAuC;AAAA,QAC/B,GAAG,KADX;AACW,QACH,CAAC,QAAQ,GAAG,aADpB;AACoB,QACZ,CAAC,SAAS,GAAG,cADrB;AACqB,OACd,CADP,CAAA;AAEM,MAAN,OAAa;AAAA,QACL,GAAG,aADX;AACW,QACH,IADR,EACc;AAAA,UACJ,CADV,EACa,aADb,CAC2B,CAD3B,GAC+B,CAD/B;AAC+B,UACrB,CADV,EACa,aADb,CAC2B,CAD3B,GAC+B,CAD/B;AAC+B,SAA/B;AACS,OAAT,CAAA;AACA,KAAA;AACK,GAAL,CAAA;AAEA,CAAA,CAAA;ADv2BA,SAAS,WAAT,CAAqB,IAArB,EAA2B;AACzB,EAAF,IAAM,MAAN,CAAa,IAAI,CAAjB,EAAoB;AAChB,IAAJ,OAAA,CAAY,IAAZ,CAAiB,QAAjB,IAA6B,EAA7B,EAAiC,WAAjC,EAAA,CAAA;AAA4C,GAA5C;AAKE,EAAF,OAAS,WAAT,CAAA;AACA,CAAA;AACA,SAAS,SAAT,CAAmB,IAAnB,EAAyB;AACvB,EAAF,IAAM,mBAAN,CAAA;AACE,EAAF,OAAA,CAAU,IAAV,IAAkB,IAAlB,IAAA,CAA2B,mBAA3B,GAAiD,IAAjD,CAAsD,aAAtD,KAAwE,IAAxE,GAA+E,KAA/E,CAAA,GAAwF,mBAAxF,CAA4G,WAA5G,KAA4H,MAA5H,CAAA;AACA,CAAA;AACA,SAAS,kBAAT,CAA4B,IAA5B,EAAkC;AAChC,EAAF,IAAM,IAAN,CAAA;AACE,EAAF,OAAA,CAAU,IAAV,GAAA,CAAkB,MAAlB,CAAyB,IAAI,CAA7B,GAAiC,IAAjC,CAAsC,aAAtC,GAAsD,IAAtD,CAA2D,QAA3D,KAAwE,MAAxE,CAA+E,QAA/E,KAA4F,IAA5F,GAAmG,KAAnG,CAAA,GAA4G,IAA5G,CAAiH,eAAjH,CAAA;AACA,CAAA;AACA,SAAS,MAAT,CAAgB,KAAhB,EAAuB;AACrB,EAAF,OAAS,KAAT,YAA0B,IAA1B,IAAkC,KAAlC,YAAmD,SAAnD,CAA6D,KAAK,CAAlE,CAAoE,IAApE,CAAA;AACA,CAAA;AACA,SAAS,SAAT,CAAmB,KAAnB,EAA0B;AACxB,EAAF,OAAS,KAAT,YAA0B,OAA1B,IAAqC,KAArC,YAAsD,SAAtD,CAAgE,KAAK,CAArE,CAAuE,OAAvE,CAAA;AACA,CAAA;AACA,SAAS,aAAT,CAAuB,KAAvB,EAA8B;AAC5B,EAAF,OAAS,KAAT,YAA0B,WAA1B,IAAyC,KAAzC,YAA0D,SAA1D,CAAoE,KAAK,CAAzE,CAA2E,WAA3E,CAAA;AACA,CAAA;AACA,SAAS,YAAT,CAAsB,KAAtB,EAA6B;AAE3B,EAAF,IAAM,OAAO,UAAb,KAA4B,WAA5B,EAAyC;AACrC,IAAJ,OAAW,KAAX,CAAA;AAAW,GAAX;AAEE,EAAF,OAAS,KAAT,YAA0B,UAA1B,IAAwC,KAAxC,YAAyD,SAAzD,CAAmE,KAAK,CAAxE,CAA0E,UAA1E,CAAA;AACA,CAAA;AACA,SAAS,iBAAT,CAA2B,OAA3B,EAAoC;AAClC,EAAF,MAAQ;AAAA,IACJ,QADJ;AACI,IACA,SADJ;AACI,IACA,SADJ;AACI,IACA,OADJ;AACI,GAAJ,GACM,gBADN,CACuB,OAAO,CAD9B,CAAA;AAEE,EAAF,OAAS,iCAAT,CAA2C,IAA3C,CAAgD,QAAhD,GAA2D,SAA3D,GAAuE,SAAS,CAAhF,IAAqF,CAAC,CAAC,QAAvF,EAAiG,UAAU,CAA3G,CAA6G,QAA7G,CAAsH,OAAO,CAA7H,CAAA;AACA,CAAA;AACA,SAAS,cAAT,CAAwB,OAAxB,EAAiC;AAC/B,EAAF,OAAS,CAAC,OAAV,EAAmB,IAAnB,EAAyB,IAAI,CAA7B,CAA+B,QAA/B,CAAwC,WAAxC,CAAoD,OAAO,CAAC,CAA5D,CAAA;AACA,CAAA;AACA,SAAS,iBAAT,CAA2B,OAA3B,EAAoC;AAClC,EAAF,MAAQ,MAAR,GAAiB,QAAjB,EAAA,CAAA;AACE,EAAF,MAAQ,GAAR,GAAc,gBAAd,CAA+B,OAAO,CAAtC,CAAA;AAGE,EAAF,OAAS,GAAT,CAAa,SAAb,KAA2B,MAA3B,IAAqC,GAArC,CAAyC,WAAzC,KAAyD,MAAzD,KAAoE,GAApE,CAAwE,aAAxE,GAAwF,GAAxF,CAA4F,aAA5F,KAA8G,QAA9G,GAAyH,KAAzH,CAAA,IAAmI,CAAC,MAApI,KAA+I,GAA/I,CAAmJ,cAAnJ,GAAoK,GAApK,CAAwK,cAAxK,KAA2L,MAA3L,GAAoM,KAApM,CAAA,IAA8M,CAAC,MAA/M,KAA0N,GAA1N,CAA8N,MAA9N,GAAuO,GAAvO,CAA2O,MAA3O,KAAsP,MAAtP,GAA+P,KAA/P,CAAA,IAAyQ,CAAC,WAA1Q,EAAuR,aAAvR,EAAsS,QAAQ,CAA9S,CAAgT,IAAhT,CAAqT,CAArT,KAAA,KAAA,CAA+T,GAA/T,CAAmU,UAAnU,IAAiV,EAAjV,EAAqV,QAArV,CAA8V,KAAK,CAAC,CAApW,IAAyW,CAAC,OAA1W,EAAmX,QAAnX,EAA6X,QAA7X,EAAuY,SAAS,CAAhZ,CAAkZ,IAAlZ,CAAuZ,CAAvZ,KAAA,KAAA,CAAia,GAAja,CAAqa,OAAra,IAAgb,EAAhb,EAAob,QAApb,CAA6b,KAAK,CAAC,CAAnc,CAAA;AACA,CAAA;AACA,SAAS,kBAAT,CAA4B,OAA5B,EAAqC;AACnC,EAAF,IAAM,WAAN,GAAoB,aAApB,CAAkC,OAAO,CAAzC,CAAA;AACE,EAAF,OAAS,aAAT,CAAuB,WAAW,CAAlC,IAAuC,CAAC,qBAAxC,CAA8D,WAAW,CAAzE,EAA4E;AACxE,IAAJ,IAAQ,iBAAR,CAA0B,WAAW,CAArC,EAAwC;AAClC,MAAN,OAAa,WAAb,CAAA;AAAa,KAAb,MACW;AACL,MAAN,WAAA,GAAoB,aAApB,CAAkC,WAAW,CAA7C,CAAA;AAA6C,KAA7C;AACK,GAAL;AAEE,EAAF,OAAS,IAAT,CAAA;AACA,CAAA;AACA,SAAS,QAAT,GAAoB;AAClB,EAAF,IAAM,OAAO,GAAb,KAAqB,WAArB,IAAoC,CAAC,GAArC,CAAyC,QAAzC;AAAmD,IAAnD,OAA0D,KAA1D,CAAA;AACE,EAAF,OAAS,GAAT,CAAa,QAAb,CAAsB,yBAAtB,EAAiD,MAAM,CAAvD,CAAA;AACA,CAAA;AACA,SAAS,qBAAT,CAA+B,IAA/B,EAAqC;AACnC,EAAF,OAAS,CAAC,MAAV,EAAkB,MAAlB,EAA0B,WAAW,CAArC,CAAuC,QAAvC,CAAgD,WAAhD,CAA4D,IAAI,CAAC,CAAjE,CAAA;AACA,CAAA;AACA,SAAS,gBAAT,CAA0B,OAA1B,EAAmC;AACjC,EAAF,OAAS,SAAT,CAAmB,OAAO,CAA1B,CAA4B,gBAA5B,CAA6C,OAAO,CAApD,CAAA;AACA,CAAA;AACA,SAAS,aAAT,CAAuB,OAAvB,EAAgC;AAC9B,EAAF,IAAM,SAAN,CAAgB,OAAO,CAAvB,EAA0B;AACtB,IAAJ,OAAW;AAAA,MACL,UADN,EACkB,OADlB,CAC0B,UAD1B;AAC0B,MACpB,SADN,EACiB,OADjB,CACyB,SADzB;AACyB,KAAzB,CAAA;AACA,GAAA;AAEE,EAAF,OAAS;AAAA,IACL,UADJ,EACgB,OADhB,CACwB,WADxB;AACwB,IACpB,SADJ,EACe,OADf,CACuB,WADvB;AACuB,GAAvB,CAAA;AAEA,CAAA;AACA,SAAS,aAAT,CAAuB,IAAvB,EAA6B;AAC3B,EAAF,IAAM,WAAN,CAAkB,IAAI,CAAtB,KAA4B,MAA5B,EAAoC;AAChC,IAAJ,OAAW,IAAX,CAAA;AAAW,GAAX;AAEE,EAAF,MAAQ,MAAR;AAAQ;AAAA,IAEN,IAFF,CAEO,YAFP;AAEO,IAEL,IAFF,CAEO,UAFP;AAEO,IAEL,YAFF,CAEe,IAAI,CAFnB,IAEwB,IAFxB,CAE6B,IAF7B;AAE6B,IAE3B,kBAFF,CAEqB,IAAI,CAFzB;AAEyB,GAAzB,CAAA;AACE,EAAF,OAAS,YAAT,CAAsB,MAAM,CAA5B,GAAgC,MAAhC,CAAuC,IAAvC,GAA8C,MAA9C,CAAA;AACA,CAAA;AACA,SAAS,0BAAT,CAAoC,IAApC,EAA0C;AACxC,EAAF,MAAQ,UAAR,GAAqB,aAArB,CAAmC,IAAI,CAAvC,CAAA;AACE,EAAF,IAAM,qBAAN,CAA4B,UAAU,CAAtC,EAAyC;AACrC,IAAJ,OAAW,IAAX,CAAgB,aAAhB,GAAgC,IAAhC,CAAqC,aAArC,CAAmD,IAAnD,GAA0D,IAA1D,CAA+D,IAA/D,CAAA;AAA+D,GAA/D;AAEE,EAAF,IAAM,aAAN,CAAoB,UAAU,CAA9B,IAAmC,iBAAnC,CAAqD,UAAU,CAA/D,EAAkE;AAC9D,IAAJ,OAAW,UAAX,CAAA;AAAW,GAAX;AAEE,EAAF,OAAS,0BAAT,CAAoC,UAAU,CAA9C,CAAA;AACA,CAAA;AACA,SAAS,oBAAT,CAA8B,IAA9B,EAAoC,IAApC,EAA0C,eAA1C,EAA2D;AACzD,EAAF,IAAM,oBAAN,CAAA;AACE,EAAF,IAAM,IAAN,KAAe,KAAf,CAAA,EAAuB;AACnB,IAAJ,IAAA,GAAW,EAAX,CAAA;AAAW,GAAX;AAEE,EAAF,IAAM,eAAN,KAA0B,KAA1B,CAAA,EAAkC;AAC9B,IAAJ,eAAA,GAAsB,IAAtB,CAAA;AAAsB,GAAtB;AAEE,EAAF,MAAQ,kBAAR,GAA6B,0BAA7B,CAAwD,IAAI,CAA5D,CAAA;AACE,EAAF,MAAQ,MAAR,GAAiB,kBAAjB,MAAA,CAA0C,oBAA1C,GAAiE,IAAjE,CAAsE,aAAtE,KAAwF,IAAxF,GAA+F,KAA/F,CAAA,GAAwG,oBAAxG,CAA6H,IAA7H,CAAA,CAAA;AACE,EAAF,MAAQ,GAAR,GAAc,SAAd,CAAwB,kBAAkB,CAA1C,CAAA;AACE,EAAF,IAAM,MAAN,EAAc;AACV,IAAJ,OAAW,IAAX,CAAgB,MAAhB,CAAuB,GAAvB,EAA4B,GAA5B,CAAgC,cAAhC,IAAkD,EAAlD,EAAsD,iBAAtD,CAAwE,kBAAkB,CAA1F,GAA8F,kBAA9F,GAAmH,EAAnH,EAAuH,GAAvH,CAA2H,YAA3H,IAA2I,eAA3I,GAA6J,oBAA7J,CAAkL,GAAlL,CAAsL,YAAY,CAAlM,GAAsM,EAAE,CAAxM,CAAA;AAAwM,GAAxM;AAEE,EAAF,OAAS,IAAT,CAAc,MAAd,CAAqB,kBAArB,EAAyC,oBAAzC,CAA8D,kBAA9D,EAAkF,EAAlF,EAAsF,eAAe,CAAC,CAAtG,CAAA;AACA,CAAA;ADvHA,SAAS,gBAAT,CAA0B,OAA1B,EAAmC;AACjC,EAAF,MAAQ,GAAR,GAAc,gBAAd,CAA+B,OAAO,CAAtC,CAAA;AAGE,EAAF,IAAM,KAAN,GAAc,UAAd,CAAyB,GAAzB,CAA6B,KAAK,CAAlC,IAAuC,CAAvC,CAAA;AACE,EAAF,IAAM,MAAN,GAAe,UAAf,CAA0B,GAA1B,CAA8B,MAAM,CAApC,IAAyC,CAAzC,CAAA;AACE,EAAF,MAAQ,SAAR,GAAoB,aAApB,CAAkC,OAAO,CAAzC,CAAA;AACE,EAAF,MAAQ,WAAR,GAAsB,SAAtB,GAAkC,OAAlC,CAA0C,WAA1C,GAAwD,KAAxD,CAAA;AACE,EAAF,MAAQ,YAAR,GAAuB,SAAvB,GAAmC,OAAnC,CAA2C,YAA3C,GAA0D,MAA1D,CAAA;AACE,EAAF,MAAQ,cAAR,GAAyB,KAAzB,CAA+B,KAAK,CAApC,KAA0C,WAA1C,IAAyD,KAAzD,CAA+D,MAAM,CAArE,KAA2E,YAA3E,CAAA;AACE,EAAF,IAAM,cAAN,EAAsB;AAClB,IAAJ,KAAA,GAAY,WAAZ,CAAA;AACI,IAAJ,MAAA,GAAa,YAAb,CAAA;AAAa,GAAb;AAEE,EAAF,OAAS;AAAA,IACL,KADJ;AACI,IACA,MADJ;AACI,IACA,CADJ,EACO,cADP;AACO,GAAP,CAAA;AAEA,CAAA;AAEA,SAAS,aAAT,CAAuB,OAAvB,EAAgC;AAC9B,EAAF,OAAS,CAAC,SAAV,CAAoB,OAAO,CAA3B,GAA+B,OAA/B,CAAuC,cAAvC,GAAwD,OAAxD,CAAA;AACA,CAAA;AAEA,SAAS,QAAT,CAAkB,OAAlB,EAA2B;AACzB,EAAF,MAAQ,UAAR,GAAqB,aAArB,CAAmC,OAAO,CAA1C,CAAA;AACE,EAAF,IAAM,CAAC,aAAP,CAAqB,UAAU,CAA/B,EAAkC;AAC9B,IAAJ,OAAW,YAAX,CAAwB,CAAC,CAAzB,CAAA;AAAyB,GAAzB;AAEE,EAAF,MAAQ,IAAR,GAAe,UAAf,CAA0B,qBAA1B,EAAA,CAAA;AACE,EAAF,MAAQ;AAAA,IACJ,KADJ;AACI,IACA,MADJ;AACI,IACA,CADJ;AACI,GAAJ,GACM,gBADN,CACuB,UAAU,CADjC,CAAA;AAEE,EAAF,IAAM,CAAN,GAAA,CAAW,CAAX,GAAe,KAAf,CAAqB,IAArB,CAA0B,KAAK,CAA/B,GAAmC,IAAnC,CAAwC,KAAxC,IAAiD,KAAjD,CAAA;AACE,EAAF,IAAM,CAAN,GAAA,CAAW,CAAX,GAAe,KAAf,CAAqB,IAArB,CAA0B,MAAM,CAAhC,GAAoC,IAApC,CAAyC,MAAzC,IAAmD,MAAnD,CAAA;AAIE,EAAF,IAAM,CAAC,CAAP,IAAY,CAAC,MAAb,CAAoB,QAApB,CAA6B,CAAC,CAA9B,EAAiC;AAC7B,IAAJ,CAAA,GAAQ,CAAR,CAAA;AAAQ,GAAR;AAEE,EAAF,IAAM,CAAC,CAAP,IAAY,CAAC,MAAb,CAAoB,QAApB,CAA6B,CAAC,CAA9B,EAAiC;AAC7B,IAAJ,CAAA,GAAQ,CAAR,CAAA;AAAQ,GAAR;AAEE,EAAF,OAAS;AAAA,IACL,CADJ;AACI,IACA,CADJ;AACI,GAAJ,CAAA;AAEA,CAAA;AAEA,MAAM,SAAN,mBAAA,YAAA,CAA4C,CAAC,CAA7C,CAAA;AACA,SAAS,gBAAT,CAA0B,OAA1B,EAAmC;AACjC,EAAF,MAAQ,GAAR,GAAc,SAAd,CAAwB,OAAO,CAA/B,CAAA;AACE,EAAF,IAAM,CAAC,QAAP,EAAA,IAAqB,CAAC,GAAtB,CAA0B,cAA1B,EAA0C;AACtC,IAAJ,OAAW,SAAX,CAAA;AAAW,GAAX;AAEE,EAAF,OAAS;AAAA,IACL,CADJ,EACO,GADP,CACW,cADX,CAC0B,UAD1B;AAC0B,IACtB,CADJ,EACO,GADP,CACW,cADX,CAC0B,SAD1B;AAC0B,GAA1B,CAAA;AAEA,CAAA;AACA,SAAS,sBAAT,CAAgC,OAAhC,EAAyC,OAAzC,EAAkD,oBAAlD,EAAwE;AACtE,EAAF,IAAM,OAAN,KAAkB,KAAlB,CAAA,EAA0B;AACtB,IAAJ,OAAA,GAAc,KAAd,CAAA;AAAc,GAAd;AAEE,EAAF,IAAM,CAAC,oBAAP,IAA+B,OAA/B,IAA0C,oBAA1C,KAAmE,SAAnE,CAA6E,OAAO,CAApF,EAAuF;AACnF,IAAJ,OAAW,KAAX,CAAA;AAAW,GAAX;AAEE,EAAF,OAAS,OAAT,CAAA;AACA,CAAA;AAEA,SAAS,qBAAT,CAA+B,OAA/B,EAAwC,YAAxC,EAAsD,eAAtD,EAAuE,YAAvE,EAAqF;AACnF,EAAF,IAAM,YAAN,KAAuB,KAAvB,CAAA,EAA+B;AAC3B,IAAJ,YAAA,GAAmB,KAAnB,CAAA;AAAmB,GAAnB;AAEE,EAAF,IAAM,eAAN,KAA0B,KAA1B,CAAA,EAAkC;AAC9B,IAAJ,eAAA,GAAsB,KAAtB,CAAA;AAAsB,GAAtB;AAEE,EAAF,MAAQ,UAAR,GAAqB,OAArB,CAA6B,qBAA7B,EAAA,CAAA;AACE,EAAF,MAAQ,UAAR,GAAqB,aAArB,CAAmC,OAAO,CAA1C,CAAA;AACE,EAAF,IAAM,KAAN,GAAc,YAAd,CAA2B,CAAC,CAA5B,CAAA;AACE,EAAF,IAAM,YAAN,EAAoB;AAChB,IAAJ,IAAQ,YAAR,EAAsB;AAChB,MAAN,IAAU,SAAV,CAAoB,YAAY,CAAhC,EAAmC;AAC3B,QAAR,KAAA,GAAgB,QAAhB,CAAyB,YAAY,CAArC,CAAA;AAAqC,OAArC;AACO,KAAP,MACW;AACL,MAAN,KAAA,GAAc,QAAd,CAAuB,OAAO,CAA9B,CAAA;AAA8B,KAA9B;AACK,GAAL;AAEE,EAAF,MAAQ,aAAR,GAAwB,sBAAxB,CAA+C,UAA/C,EAA2D,eAA3D,EAA4E,YAAY,CAAxF,GAA4F,gBAA5F,CAA6G,UAAU,CAAvH,GAA2H,YAA3H,CAAwI,CAAC,CAAzI,CAAA;AACE,EAAF,IAAM,CAAN,GAAA,CAAW,UAAX,CAAsB,IAAtB,GAA6B,aAA7B,CAA2C,CAA3C,IAAgD,KAAhD,CAAsD,CAAtD,CAAA;AACE,EAAF,IAAM,CAAN,GAAA,CAAW,UAAX,CAAsB,GAAtB,GAA4B,aAA5B,CAA0C,CAA1C,IAA+C,KAA/C,CAAqD,CAArD,CAAA;AACE,EAAF,IAAM,KAAN,GAAc,UAAd,CAAyB,KAAzB,GAAiC,KAAjC,CAAuC,CAAvC,CAAA;AACE,EAAF,IAAM,MAAN,GAAe,UAAf,CAA0B,MAA1B,GAAmC,KAAnC,CAAyC,CAAzC,CAAA;AACE,EAAF,IAAM,UAAN,EAAkB;AACd,IAAJ,MAAU,GAAV,GAAgB,SAAhB,CAA0B,UAAU,CAApC,CAAA;AACI,IAAJ,MAAU,SAAV,GAAsB,YAAtB,IAAsC,SAAtC,CAAgD,YAAY,CAA5D,GAAgE,SAAhE,CAA0E,YAAY,CAAtF,GAA0F,YAA1F,CAAA;AACI,IAAJ,IAAQ,aAAR,GAAwB,GAAxB,CAA4B,YAA5B,CAAA;AACI,IAAJ,OAAW,aAAX,IAA4B,YAA5B,IAA4C,SAA5C,KAA0D,GAA1D,EAA+D;AACzD,MAAN,MAAY,WAAZ,GAA0B,QAA1B,CAAmC,aAAa,CAAhD,CAAA;AACM,MAAN,MAAY,UAAZ,GAAyB,aAAzB,CAAuC,qBAAvC,EAAA,CAAA;AACM,MAAN,MAAY,GAAZ,GAAkB,gBAAlB,CAAmC,aAAa,CAAhD,CAAA;AACM,MAAN,MAAY,IAAZ,GAAmB,UAAnB,CAA8B,IAA9B,GAAA,CAAsC,aAAtC,CAAoD,UAApD,GAAiE,UAAjE,CAA4E,GAA5E,CAAgF,WAAW,CAA3F,IAAgG,WAAhG,CAA4G,CAA5G,CAAA;AACM,MAAN,MAAY,GAAZ,GAAkB,UAAlB,CAA6B,GAA7B,GAAA,CAAoC,aAApC,CAAkD,SAAlD,GAA8D,UAA9D,CAAyE,GAAzE,CAA6E,UAAU,CAAvF,IAA4F,WAA5F,CAAwG,CAAxG,CAAA;AACM,MAAN,CAAA,IAAW,WAAX,CAAuB,CAAvB,CAAA;AACM,MAAN,CAAA,IAAW,WAAX,CAAuB,CAAvB,CAAA;AACM,MAAN,KAAA,IAAe,WAAf,CAA2B,CAA3B,CAAA;AACM,MAAN,MAAA,IAAgB,WAAhB,CAA4B,CAA5B,CAAA;AACM,MAAN,CAAA,IAAW,IAAX,CAAA;AACM,MAAN,CAAA,IAAW,GAAX,CAAA;AACM,MAAN,aAAA,GAAsB,SAAtB,CAAgC,aAAa,CAA7C,CAA+C,YAA/C,CAAA;AAA+C,KAA/C;AACK,GAAL;AAEE,EAAF,OAAS,gBAAT,CAA0B;AAAA,IACtB,KADJ;AACI,IACA,MADJ;AACI,IACA,CADJ;AACI,IACA,CADJ;AACI,GACD,CADH,CAAA;AAEA,CAAA;AAEA,SAAS,qDAAT,CAA+D,IAA/D,EAAqE;AACnE,EAAF,IAAM;AAAA,IACF,IADJ;AACI,IACA,YADJ;AACI,IACA,QADJ;AACI,GAAJ,GACM,IADN,CAAA;AAEE,EAAF,MAAQ,uBAAR,GAAkC,aAAlC,CAAgD,YAAY,CAA5D,CAAA;AACE,EAAF,MAAQ,eAAR,GAA0B,kBAA1B,CAA6C,YAAY,CAAzD,CAAA;AACE,EAAF,IAAM,YAAN,KAAuB,eAAvB,EAAwC;AACpC,IAAJ,OAAW,IAAX,CAAA;AAAW,GAAX;AAEE,EAAF,IAAM,MAAN,GAAe;AAAA,IACX,UADJ,EACgB,CADhB;AACgB,IACZ,SADJ,EACe,CADf;AACe,GAAf,CAAA;AAEE,EAAF,IAAM,KAAN,GAAc,YAAd,CAA2B,CAAC,CAA5B,CAAA;AACE,EAAF,MAAQ,OAAR,GAAkB,YAAlB,CAA+B,CAAC,CAAhC,CAAA;AACE,EAAF,IAAM,uBAAN,IAAiC,CAAC,uBAAlC,IAA6D,QAA7D,KAA0E,OAA1E,EAAmF;AAC/E,IAAJ,IAAQ,WAAR,CAAoB,YAAY,CAAhC,KAAsC,MAAtC,IAAgD,iBAAhD,CAAkE,eAAe,CAAjF,EAAoF;AAC9E,MAAN,MAAA,GAAe,aAAf,CAA6B,YAAY,CAAzC,CAAA;AAAyC,KAAzC;AAEI,IAAJ,IAAQ,aAAR,CAAsB,YAAY,CAAlC,EAAqC;AAC/B,MAAN,MAAY,UAAZ,GAAyB,qBAAzB,CAA+C,YAAY,CAA3D,CAAA;AACM,MAAN,KAAA,GAAc,QAAd,CAAuB,YAAY,CAAnC,CAAA;AACM,MAAN,OAAA,CAAc,CAAd,GAAkB,UAAlB,CAA6B,CAA7B,GAAiC,YAAjC,CAA8C,UAA9C,CAAA;AACM,MAAN,OAAA,CAAc,CAAd,GAAkB,UAAlB,CAA6B,CAA7B,GAAiC,YAAjC,CAA8C,SAA9C,CAAA;AAA8C,KAA9C;AACK,GAAL;AAEE,EAAF,OAAS;AAAA,IACL,KADJ,EACW,IADX,CACgB,KADhB,GACwB,KADxB,CAC8B,CAD9B;AAC8B,IAC1B,MADJ,EACY,IADZ,CACiB,MADjB,GAC0B,KAD1B,CACgC,CADhC;AACgC,IAC5B,CADJ,EACO,IADP,CACY,CADZ,GACgB,KADhB,CACsB,CADtB,GAC0B,MAD1B,CACiC,UADjC,GAC8C,KAD9C,CACoD,CADpD,GACwD,OADxD,CACgE,CADhE;AACgE,IAC5D,CADJ,EACO,IADP,CACY,CADZ,GACgB,KADhB,CACsB,CADtB,GAC0B,MAD1B,CACiC,SADjC,GAC6C,KAD7C,CACmD,CADnD,GACuD,OADvD,CAC+D,CAD/D;AAC+D,GAA/D,CAAA;AAEA,CAAA;AAEA,SAAS,cAAT,CAAwB,OAAxB,EAAiC;AAC/B,EAAF,OAAS,KAAT,CAAe,IAAf,CAAoB,OAApB,CAA4B,cAA5B,EAA4C,CAA5C,CAAA;AACA,CAAA;AAEA,SAAS,mBAAT,CAA6B,OAA7B,EAAsC;AAGpC,EAAF,OAAS,qBAAT,CAA+B,kBAA/B,CAAkD,OAAO,CAAC,CAA1D,CAA4D,IAA5D,GAAmE,aAAnE,CAAiF,OAAO,CAAxF,CAA0F,UAA1F,CAAA;AACA,CAAA;AAIA,SAAS,eAAT,CAAyB,OAAzB,EAAkC;AAChC,EAAF,MAAQ,IAAR,GAAe,kBAAf,CAAkC,OAAO,CAAzC,CAAA;AACE,EAAF,MAAQ,MAAR,GAAiB,aAAjB,CAA+B,OAAO,CAAtC,CAAA;AACE,EAAF,MAAQ,IAAR,GAAe,OAAf,CAAuB,aAAvB,CAAqC,IAArC,CAAA;AACE,EAAF,MAAQ,KAAR,GAAgB,GAAhB,CAAoB,IAApB,CAAyB,WAAzB,EAAsC,IAAtC,CAA2C,WAA3C,EAAwD,IAAxD,CAA6D,WAA7D,EAA0E,IAA1E,CAA+E,WAAW,CAA1F,CAAA;AACE,EAAF,MAAQ,MAAR,GAAiB,GAAjB,CAAqB,IAArB,CAA0B,YAA1B,EAAwC,IAAxC,CAA6C,YAA7C,EAA2D,IAA3D,CAAgE,YAAhE,EAA8E,IAA9E,CAAmF,YAAY,CAA/F,CAAA;AACE,EAAF,IAAM,CAAN,GAAU,CAAC,MAAX,CAAkB,UAAlB,GAA+B,mBAA/B,CAAmD,OAAO,CAA1D,CAAA;AACE,EAAF,MAAQ,CAAR,GAAY,CAAC,MAAb,CAAoB,SAApB,CAAA;AACE,EAAF,IAAM,gBAAN,CAAuB,IAAI,CAA3B,CAA6B,SAA7B,KAA2C,KAA3C,EAAkD;AAC9C,IAAJ,CAAA,IAAS,GAAT,CAAa,IAAb,CAAkB,WAAlB,EAA+B,IAA/B,CAAoC,WAAW,CAA/C,GAAmD,KAAnD,CAAA;AAAmD,GAAnD;AAEE,EAAF,OAAS;AAAA,IACL,KADJ;AACI,IACA,MADJ;AACI,IACA,CADJ;AACI,IACA,CADJ;AACI,GAAJ,CAAA;AAEA,CAAA;AAEA,SAAS,eAAT,CAAyB,OAAzB,EAAkC,QAAlC,EAA4C;AAC1C,EAAF,MAAQ,GAAR,GAAc,SAAd,CAAwB,OAAO,CAA/B,CAAA;AACE,EAAF,MAAQ,IAAR,GAAe,kBAAf,CAAkC,OAAO,CAAzC,CAAA;AACE,EAAF,MAAQ,cAAR,GAAyB,GAAzB,CAA6B,cAA7B,CAAA;AACE,EAAF,IAAM,KAAN,GAAc,IAAd,CAAmB,WAAnB,CAAA;AACE,EAAF,IAAM,MAAN,GAAe,IAAf,CAAoB,YAApB,CAAA;AACE,EAAF,IAAM,CAAN,GAAU,CAAV,CAAA;AACE,EAAF,IAAM,CAAN,GAAU,CAAV,CAAA;AACE,EAAF,IAAM,cAAN,EAAsB;AAClB,IAAJ,KAAA,GAAY,cAAZ,CAA2B,KAA3B,CAAA;AACI,IAAJ,MAAA,GAAa,cAAb,CAA4B,MAA5B,CAAA;AACI,IAAJ,MAAU,mBAAV,GAAgC,QAAhC,EAAA,CAAA;AACI,IAAJ,IAAQ,CAAC,mBAAT,IAAgC,mBAAhC,IAAuD,QAAvD,KAAoE,OAApE,EAA6E;AACvE,MAAN,CAAA,GAAU,cAAV,CAAyB,UAAzB,CAAA;AACM,MAAN,CAAA,GAAU,cAAV,CAAyB,SAAzB,CAAA;AAAyB,KAAzB;AACK,GAAL;AAEE,EAAF,OAAS;AAAA,IACL,KADJ;AACI,IACA,MADJ;AACI,IACA,CADJ;AACI,IACA,CADJ;AACI,GAAJ,CAAA;AAEA,CAAA;AAGA,SAAS,0BAAT,CAAoC,OAApC,EAA6C,QAA7C,EAAuD;AACrD,EAAF,MAAQ,UAAR,GAAqB,qBAArB,CAA2C,OAA3C,EAAoD,IAApD,EAA0D,QAA1D,KAAuE,OAAO,CAA9E,CAAA;AACE,EAAF,MAAQ,GAAR,GAAc,UAAd,CAAyB,GAAzB,GAA+B,OAA/B,CAAuC,SAAvC,CAAA;AACE,EAAF,MAAQ,IAAR,GAAe,UAAf,CAA0B,IAA1B,GAAiC,OAAjC,CAAyC,UAAzC,CAAA;AACE,EAAF,MAAQ,KAAR,GAAgB,aAAhB,CAA8B,OAAO,CAArC,GAAyC,QAAzC,CAAkD,OAAO,CAAzD,GAA6D,YAA7D,CAA0E,CAAC,CAA3E,CAAA;AACE,EAAF,MAAQ,KAAR,GAAgB,OAAhB,CAAwB,WAAxB,GAAsC,KAAtC,CAA4C,CAA5C,CAAA;AACE,EAAF,MAAQ,MAAR,GAAiB,OAAjB,CAAyB,YAAzB,GAAwC,KAAxC,CAA8C,CAA9C,CAAA;AACE,EAAF,MAAQ,CAAR,GAAY,IAAZ,GAAmB,KAAnB,CAAyB,CAAzB,CAAA;AACE,EAAF,MAAQ,CAAR,GAAY,GAAZ,GAAkB,KAAlB,CAAwB,CAAxB,CAAA;AACE,EAAF,OAAS;AAAA,IACL,KADJ;AACI,IACA,MADJ;AACI,IACA,CADJ;AACI,IACA,CADJ;AACI,GAAJ,CAAA;AAEA,CAAA;AACA,SAAS,iCAAT,CAA2C,OAA3C,EAAoD,gBAApD,EAAsE,QAAtE,EAAgF;AAC9E,EAAF,IAAM,IAAN,CAAA;AACE,EAAF,IAAM,gBAAN,KAA2B,UAA3B,EAAuC;AACnC,IAAJ,IAAA,GAAW,eAAX,CAA2B,OAA3B,EAAoC,QAAQ,CAA5C,CAAA;AAA4C,GAA5C,MAAA,IACa,gBADb,KACkC,UADlC,EAC8C;AAC1C,IAAJ,IAAA,GAAW,eAAX,CAA2B,kBAA3B,CAA8C,OAAO,CAAC,CAAtD,CAAA;AAAsD,GAAtD,MAAA,IACa,SADb,CACuB,gBAAgB,CADvC,EAC0C;AACtC,IAAJ,IAAA,GAAW,0BAAX,CAAsC,gBAAtC,EAAwD,QAAQ,CAAhE,CAAA;AAAgE,GAAhE,MACS;AACL,IAAJ,MAAU,aAAV,GAA0B,gBAA1B,CAA2C,OAAO,CAAlD,CAAA;AACI,IAAJ,IAAA,GAAW;AAAA,MACL,GAAG,gBADT;AACS,MACH,CADN,EACS,gBADT,CAC0B,CAD1B,GAC8B,aAD9B,CAC4C,CAD5C;AAC4C,MACtC,CADN,EACS,gBADT,CAC0B,CAD1B,GAC8B,aAD9B,CAC4C,CAD5C;AAC4C,KAA5C,CAAA;AACA,GAAA;AAEE,EAAF,OAAS,gBAAT,CAA0B,IAAI,CAA9B,CAAA;AACA,CAAA;AACA,SAAS,wBAAT,CAAkC,OAAlC,EAA2C,QAA3C,EAAqD;AACnD,EAAF,MAAQ,UAAR,GAAqB,aAArB,CAAmC,OAAO,CAA1C,CAAA;AACE,EAAF,IAAM,UAAN,KAAqB,QAArB,IAAiC,CAAC,SAAlC,CAA4C,UAAU,CAAtD,IAA2D,qBAA3D,CAAiF,UAAU,CAA3F,EAA8F;AAC1F,IAAJ,OAAW,KAAX,CAAA;AAAW,GAAX;AAEE,EAAF,OAAS,gBAAT,CAA0B,UAAU,CAApC,CAAsC,QAAtC,KAAmD,OAAnD,IAA8D,wBAA9D,CAAuF,UAAvF,EAAmG,QAAQ,CAA3G,CAAA;AACA,CAAA;AAKA,SAAS,2BAAT,CAAqC,OAArC,EAA8C,KAA9C,EAAqD;AACnD,EAAF,MAAQ,YAAR,GAAuB,KAAvB,CAA6B,GAA7B,CAAiC,OAAO,CAAxC,CAAA;AACE,EAAF,IAAM,YAAN,EAAoB;AAChB,IAAJ,OAAW,YAAX,CAAA;AAAW,GAAX;AAEE,EAAF,IAAM,MAAN,GAAe,oBAAf,CAAoC,OAApC,EAA6C,EAA7C,EAAiD,KAAK,CAAtD,CAAwD,MAAxD,CAA+D,CAA/D,EAAA,KAAqE,SAArE,CAA+E,EAAE,CAAjF,IAAsF,WAAtF,CAAkG,EAAE,CAApG,KAA0G,MAAM,CAAhH,CAAA;AACE,EAAF,IAAM,mCAAN,GAA4C,IAA5C,CAAA;AACE,EAAF,MAAQ,cAAR,GAAyB,gBAAzB,CAA0C,OAAO,CAAjD,CAAmD,QAAnD,KAAgE,OAAhE,CAAA;AACE,EAAF,IAAM,WAAN,GAAoB,cAApB,GAAqC,aAArC,CAAmD,OAAO,CAA1D,GAA8D,OAA9D,CAAA;AAGE,EAAF,OAAS,SAAT,CAAmB,WAAW,CAA9B,IAAmC,CAAC,qBAApC,CAA0D,WAAW,CAArE,EAAwE;AACpE,IAAJ,MAAU,aAAV,GAA0B,gBAA1B,CAA2C,WAAW,CAAtD,CAAA;AACI,IAAJ,MAAU,uBAAV,GAAoC,iBAApC,CAAsD,WAAW,CAAjE,CAAA;AACI,IAAJ,IAAQ,CAAC,uBAAT,IAAoC,aAApC,CAAkD,QAAlD,KAA+D,OAA/D,EAAwE;AAClE,MAAN,mCAAA,GAA4C,IAA5C,CAAA;AAA4C,KAA5C;AAEI,IAAJ,MAAU,qBAAV,GAAkC,cAAlC,GAAmD,CAAC,uBAApD,IAA+E,CAAC,mCAAhF,GAAsH,CAAC,uBAAvH,IAAkJ,aAAlJ,CAAgK,QAAhK,KAA6K,QAA7K,IAAyL,CAAC,CAAC,mCAA3L,IAAkO,CAAC,UAAnO,EAA+O,OAAO,CAAtP,CAAwP,QAAxP,CAAiQ,mCAAjQ,CAAqS,QAAQ,CAA7S,IAAkT,iBAAlT,CAAoU,WAAW,CAA/U,IAAoV,CAAC,uBAArV,IAAgX,wBAAhX,CAAyY,OAAzY,EAAkZ,WAAW,CAA7Z,CAAA;AACI,IAAJ,IAAQ,qBAAR,EAA+B;AAEzB,MAAN,MAAA,GAAe,MAAf,CAAsB,MAAtB,CAA6B,CAA7B,QAAA,KAAyC,QAAzC,KAAsD,WAAW,CAAjE,CAAA;AAAiE,KAAjE,MACW;AAEL,MAAN,mCAAA,GAA4C,aAA5C,CAAA;AAA4C,KAA5C;AAEI,IAAJ,WAAA,GAAkB,aAAlB,CAAgC,WAAW,CAA3C,CAAA;AAA2C,GAA3C;AAEE,EAAF,KAAA,CAAQ,GAAR,CAAY,OAAZ,EAAqB,MAAM,CAA3B,CAAA;AACE,EAAF,OAAS,MAAT,CAAA;AACA,CAAA;AAIA,SAAS,eAAT,CAAyB,IAAzB,EAA+B;AAC7B,EAAF,IAAM;AAAA,IACF,OADJ;AACI,IACA,QADJ;AACI,IACA,YADJ;AACI,IACA,QADJ;AACI,GAAJ,GACM,IADN,CAAA;AAEE,EAAF,MAAQ,wBAAR,GAAmC,QAAnC,KAAgD,mBAAhD,GAAsE,2BAAtE,CAAkG,OAAlG,EAA2G,IAA3G,CAAgH,EAAE,CAAlH,GAAsH,EAAtH,CAAyH,MAAzH,CAAgI,QAAQ,CAAxI,CAAA;AACE,EAAF,MAAQ,iBAAR,GAA4B,CAAC,GAAG,wBAAhC,EAA0D,YAAY,CAAtE,CAAA;AACE,EAAF,MAAQ,qBAAR,GAAgC,iBAAhC,CAAkD,CAAC,CAAnD,CAAA;AACE,EAAF,MAAQ,YAAR,GAAuB,iBAAvB,CAAyC,MAAzC,CAAgD,CAAC,OAAjD,EAA0D,gBAA1D,KAA+E;AAC3E,IAAJ,MAAU,IAAV,GAAiB,iCAAjB,CAAmD,OAAnD,EAA4D,gBAA5D,EAA8E,QAAQ,CAAtF,CAAA;AACI,IAAJ,OAAA,CAAY,GAAZ,GAAkB,GAAlB,CAAsB,IAAtB,CAA2B,GAA3B,EAAgC,OAAhC,CAAwC,GAAG,CAA3C,CAAA;AACI,IAAJ,OAAA,CAAY,KAAZ,GAAoB,GAApB,CAAwB,IAAxB,CAA6B,KAA7B,EAAoC,OAApC,CAA4C,KAAK,CAAjD,CAAA;AACI,IAAJ,OAAA,CAAY,MAAZ,GAAqB,GAArB,CAAyB,IAAzB,CAA8B,MAA9B,EAAsC,OAAtC,CAA8C,MAAM,CAApD,CAAA;AACI,IAAJ,OAAA,CAAY,IAAZ,GAAmB,GAAnB,CAAuB,IAAvB,CAA4B,IAA5B,EAAkC,OAAlC,CAA0C,IAAI,CAA9C,CAAA;AACI,IAAJ,OAAW,OAAX,CAAA;AAAW,GAAX,EACK,iCADL,CACuC,OADvC,EACgD,qBADhD,EACuE,QAAQ,CAAC,CADhF,CAAA;AAEE,EAAF,OAAS;AAAA,IACL,KADJ,EACW,YADX,CACwB,KADxB,GACgC,YADhC,CAC6C,IAD7C;AAC6C,IACzC,MADJ,EACY,YADZ,CACyB,MADzB,GACkC,YADlC,CAC+C,GAD/C;AAC+C,IAC3C,CADJ,EACO,YADP,CACoB,IADpB;AACoB,IAChB,CADJ,EACO,YADP,CACoB,GADpB;AACoB,GAApB,CAAA;AAEA,CAAA;AAEA,SAAS,aAAT,CAAuB,OAAvB,EAAgC;AAC9B,EAAF,MAAQ;AAAA,IACJ,KADJ;AACI,IACA,MADJ;AACI,GAAJ,GACM,gBADN,CACuB,OAAO,CAD9B,CAAA;AAEE,EAAF,OAAS;AAAA,IACL,KADJ;AACI,IACA,MADJ;AACI,GAAJ,CAAA;AAEA,CAAA;AAEA,SAAS,6BAAT,CAAuC,OAAvC,EAAgD,YAAhD,EAA8D,QAA9D,EAAwE;AACtE,EAAF,MAAQ,uBAAR,GAAkC,aAAlC,CAAgD,YAAY,CAA5D,CAAA;AACE,EAAF,MAAQ,eAAR,GAA0B,kBAA1B,CAA6C,YAAY,CAAzD,CAAA;AACE,EAAF,MAAQ,OAAR,GAAkB,QAAlB,KAA+B,OAA/B,CAAA;AACE,EAAF,MAAQ,IAAR,GAAe,qBAAf,CAAqC,OAArC,EAA8C,IAA9C,EAAoD,OAApD,EAA6D,YAAY,CAAzE,CAAA;AACE,EAAF,IAAM,MAAN,GAAe;AAAA,IACX,UADJ,EACgB,CADhB;AACgB,IACZ,SADJ,EACe,CADf;AACe,GAAf,CAAA;AAEE,EAAF,MAAQ,OAAR,GAAkB,YAAlB,CAA+B,CAAC,CAAhC,CAAA;AACE,EAAF,IAAM,uBAAN,IAAiC,CAAC,uBAAlC,IAA6D,CAAC,OAA9D,EAAuE;AACnE,IAAJ,IAAQ,WAAR,CAAoB,YAAY,CAAhC,KAAsC,MAAtC,IAAgD,iBAAhD,CAAkE,eAAe,CAAjF,EAAoF;AAC9E,MAAN,MAAA,GAAe,aAAf,CAA6B,YAAY,CAAzC,CAAA;AAAyC,KAAzC;AAEI,IAAJ,IAAQ,uBAAR,EAAiC;AAC3B,MAAN,MAAY,UAAZ,GAAyB,qBAAzB,CAA+C,YAA/C,EAA6D,IAA7D,EAAmE,OAAnE,EAA4E,YAAY,CAAxF,CAAA;AACM,MAAN,OAAA,CAAc,CAAd,GAAkB,UAAlB,CAA6B,CAA7B,GAAiC,YAAjC,CAA8C,UAA9C,CAAA;AACM,MAAN,OAAA,CAAc,CAAd,GAAkB,UAAlB,CAA6B,CAA7B,GAAiC,YAAjC,CAA8C,SAA9C,CAAA;AAA8C,KAA9C,MAAA,IACe,eADf,EACgC;AAC1B,MAAN,OAAA,CAAc,CAAd,GAAkB,mBAAlB,CAAsC,eAAe,CAArD,CAAA;AAAqD,KAArD;AACK,GAAL;AAEE,EAAF,OAAS;AAAA,IACL,CADJ,EACO,IADP,CACY,IADZ,GACmB,MADnB,CAC0B,UAD1B,GACuC,OADvC,CAC+C,CAD/C;AAC+C,IAC3C,CADJ,EACO,IADP,CACY,GADZ,GACkB,MADlB,CACyB,SADzB,GACqC,OADrC,CAC6C,CAD7C;AAC6C,IACzC,KADJ,EACW,IADX,CACgB,KADhB;AACgB,IACZ,MADJ,EACY,IADZ,CACiB,MADjB;AACiB,GAAjB,CAAA;AAEA,CAAA;AAEA,SAAS,mBAAT,CAA6B,OAA7B,EAAsC,QAAtC,EAAgD;AAC9C,EAAF,IAAM,CAAC,aAAP,CAAqB,OAAO,CAA5B,IAAiC,gBAAjC,CAAkD,OAAO,CAAzD,CAA2D,QAA3D,KAAwE,OAAxE,EAAiF;AAC7E,IAAJ,OAAW,IAAX,CAAA;AAAW,GAAX;AAEE,EAAF,IAAM,QAAN,EAAgB;AACZ,IAAJ,OAAW,QAAX,CAAoB,OAAO,CAA3B,CAAA;AAA2B,GAA3B;AAEE,EAAF,OAAS,OAAT,CAAiB,YAAjB,CAAA;AACA,CAAA;AAIA,SAAS,eAAT,CAAyB,OAAzB,EAAkC,QAAlC,EAA4C;AAC1C,EAAF,MAAQF,OAAR,GAAiB,SAAjB,CAA2B,OAAO,CAAlC,CAAA;AACE,EAAF,IAAM,CAAC,aAAP,CAAqB,OAAO,CAA5B,EAA+B;AAC3B,IAAJ,OAAWA,OAAX,CAAA;AAAW,GAAX;AAEE,EAAF,IAAM,YAAN,GAAqB,mBAArB,CAAyC,OAAzC,EAAkD,QAAQ,CAA1D,CAAA;AACE,EAAF,OAAS,YAAT,IAAyB,cAAzB,CAAwC,YAAY,CAApD,IAAyD,gBAAzD,CAA0E,YAAY,CAAtF,CAAwF,QAAxF,KAAqG,QAArG,EAA+G;AAC3G,IAAJ,YAAA,GAAmB,mBAAnB,CAAuC,YAAvC,EAAqD,QAAQ,CAA7D,CAAA;AAA6D,GAA7D;AAEE,EAAF,IAAM,YAAN,KAAuB,WAAvB,CAAmC,YAAY,CAA/C,KAAqD,MAArD,IAA+D,WAA/D,CAA2E,YAAY,CAAvF,KAA6F,MAA7F,IAAuG,gBAAvG,CAAwH,YAAY,CAApI,CAAsI,QAAtI,KAAmJ,QAAnJ,IAA+J,CAAC,iBAAhK,CAAkL,YAAY,CAA9L,CAAA,EAAkM;AAC9L,IAAJ,OAAWA,OAAX,CAAA;AAAW,GAAX;AAEE,EAAF,OAAS,YAAT,IAAyB,kBAAzB,CAA4C,OAAO,CAAnD,IAAwDA,OAAxD,CAAA;AACA,CAAA;AAEA,MAAM,eAAN,GAAwB,eAAgB,IAAxC,EAA8C;AAC5C,EAAF,IAAM;AAAA,IACF,SADJ;AACI,IACA,QADJ;AACI,IACA,QADJ;AACI,GAAJ,GACM,IADN,CAAA;AAEE,EAAF,MAAQ,iBAAR,GAA4B,IAA5B,CAAiC,eAAjC,IAAoD,eAApD,CAAA;AACE,EAAF,MAAQ,eAAR,GAA0B,IAA1B,CAA+B,aAA/B,CAAA;AACE,EAAF,OAAS;AAAA,IACL,SADJ,EACe,6BADf,CAC6C,SAD7C,EACwD,MAAM,iBAD9D,CACgF,QAAQ,CADxF,EAC2F,QAAQ,CADnG;AACmG,IAC/F,QADJ,EACc;AAAA,MACR,CADN,EACS,CADT;AACS,MACH,CADN,EACS,CADT;AACS,MACH,GAAI,MAAM,eADhB,CACgC,QAAQ,CADxC;AACwC,KAAxC;AACK,GAAL,CAAA;AAEA,CAAA,CAAA;AAEA,SAAS,KAAT,CAAe,OAAf,EAAwB;AACtB,EAAF,OAAS,gBAAT,CAA0B,OAAO,CAAjC,CAAmC,SAAnC,KAAiD,KAAjD,CAAA;AACA,CAAA;AAEA,MAAM,QAAN,GAAiB;AAAA,EACf,qDADF;AACE,EACA,kBADF;AACE,EACA,eADF;AACE,EACA,eADF;AACE,EACA,eADF;AACE,EACA,cADF;AACE,EACA,aADF;AACE,EACA,QADF;AACE,EACA,SADF;AACE,EACA,KADF;AAEA,CAAA,CAAA;AAGA,SAAS,WAAT,CAAqB,OAArB,EAA8B,MAA9B,EAAsC;AACpC,EAAF,IAAM,EAAN,GAAW,IAAX,CAAA;AACE,EAAF,IAAM,SAAN,CAAA;AACE,EAAF,MAAQ,IAAR,GAAe,kBAAf,CAAkC,OAAO,CAAzC,CAAA;AACE,EAAF,SAAW,OAAX,GAAqB;AACjB,IAAJ,YAAA,CAAiB,SAAS,CAA1B,CAAA;AACI,IAAJ,EAAA,IAAU,EAAV,CAAa,UAAb,EAAA,CAAA;AACI,IAAJ,EAAA,GAAS,IAAT,CAAA;AAAS,GAAT;AAEE,EAAF,SAAW,OAAX,CAAmB,IAAnB,EAAyB,SAAzB,EAAoC;AAChC,IAAJ,IAAQ,IAAR,KAAiB,KAAjB,CAAA,EAAyB;AACnB,MAAN,IAAA,GAAa,KAAb,CAAA;AAAa,KAAb;AAEI,IAAJ,IAAQ,SAAR,KAAsB,KAAtB,CAAA,EAA8B;AACxB,MAAN,SAAA,GAAkB,CAAlB,CAAA;AAAkB,KAAlB;AAEI,IAAJ,OAAA,EAAA,CAAA;AACI,IAAJ,MAAU;AAAA,MACJ,IADN;AACM,MACA,GADN;AACM,MACA,KADN;AACM,MACA,MADN;AACM,KAAN,GACQ,OADR,CACgB,qBADhB,EAAA,CAAA;AAEI,IAAJ,IAAQ,CAAC,IAAT,EAAe;AACT,MAAN,MAAA,EAAA,CAAA;AACA,KAAA;AACI,IAAJ,IAAQ,CAAC,KAAT,IAAkB,CAAC,MAAnB,EAA2B;AACrB,MAAN,OAAA;AAAM,KAAN;AAEI,IAAJ,MAAU,QAAV,GAAqB,KAArB,CAA2B,GAAG,CAA9B,CAAA;AACI,IAAJ,MAAU,UAAV,GAAuB,KAAvB,CAA6B,IAA7B,CAAkC,WAAlC,IAAiD,IAAjD,GAAwD,KAAxD,CAA8D,CAA9D,CAAA;AACI,IAAJ,MAAU,WAAV,GAAwB,KAAxB,CAA8B,IAA9B,CAAmC,YAAnC,IAAmD,GAAnD,GAAyD,MAAzD,CAAgE,CAAhE,CAAA;AACI,IAAJ,MAAU,SAAV,GAAsB,KAAtB,CAA4B,IAAI,CAAhC,CAAA;AACI,IAAJ,MAAU,UAAV,GAAuB,CAAC,QAAxB,GAAmC,KAAnC,GAA2C,CAAC,UAA5C,GAAyD,KAAzD,GAAiE,CAAC,WAAlE,GAAgF,KAAhF,GAAwF,CAAC,SAAzF,GAAqG,IAArG,CAAA;AACI,IAAJ,MAAU,OAAV,GAAoB;AAAA,MACd,UADN;AACM,MACA,SADN,EACiB,GADjB,CACqB,CADrB,EACwB,GADxB,CAC4B,CAD5B,EAC+B,SAAS,CAAC,CADzC,IAC8C,CAD9C;AAC8C,KAA9C,CAAA;AAEI,IAAJ,IAAQ,aAAR,GAAwB,IAAxB,CAAA;AACI,IAAJ,SAAa,aAAb,CAA2B,OAA3B,EAAoC;AAC9B,MAAN,MAAY,KAAZ,GAAoB,OAApB,CAA4B,CAAC,CAA7B,CAA+B,iBAA/B,CAAA;AACM,MAAN,IAAU,KAAV,KAAoB,SAApB,EAA+B;AACvB,QAAR,IAAY,CAAC,aAAb,EAA4B;AAClB,UAAV,OAAiB,OAAjB,EAAA,CAAA;AAAwB,SAAxB;AAEQ,QAAR,IAAY,CAAC,KAAb,EAAoB;AACV,UAAV,SAAA,GAAsB,UAAtB,CAAiC,MAAM;AAC3B,YAAZ,OAAA,CAAoB,KAApB,EAA2B,IAAI,CAA/B,CAAA;AAA+B,WAA/B,EACa,GAAG,CADhB,CAAA;AACgB,SAAhB,MACe;AACL,UAAV,OAAA,CAAkB,KAAlB,EAAyB,KAAK,CAA9B,CAAA;AAA8B,SAA9B;AACS,OAAT;AAEM,MAAN,aAAA,GAAsB,KAAtB,CAAA;AAAsB,KAAtB;AAKI,IAAJ,IAAQ;AACF,MAAN,EAAA,GAAW,IAAI,oBAAf,CAAoC,aAApC,EAAmD;AAAA,QAC3C,GAAG,OADX;AACW;AAAA,QAEH,IAFR,EAEc,IAFd,CAEmB,aAFnB;AAEmB,OACZ,CADP,CAAA;AACO,KAAP,CAAA,OACa,CADb,EACgB;AACV,MAAN,EAAA,GAAW,IAAI,oBAAf,CAAoC,aAApC,EAAmD,OAAO,CAA1D,CAAA;AAA0D,KAA1D;AAEI,IAAJ,EAAA,CAAO,OAAP,CAAe,OAAO,CAAtB,CAAA;AAAsB,GAAtB;AAEE,EAAF,OAAA,CAAU,IAAI,CAAd,CAAA;AACE,EAAF,OAAS,OAAT,CAAA;AACA,CAAA;AAUA,SAAS,UAAT,CAAoB,SAApB,EAA+B,QAA/B,EAAyC,MAAzC,EAAiD,OAAjD,EAA0D;AACxD,EAAF,IAAM,OAAN,KAAkB,KAAlB,CAAA,EAA0B;AACtB,IAAJ,OAAA,GAAc,EAAd,CAAA;AAAc,GAAd;AAEE,EAAF,MAAQ;AAAA,IACJ,cADJ,GACqB,IADrB;AACqB,IACjB,cADJ,GACqB,IADrB;AACqB,IACjB,aADJ,GACoB,OAAO,cAD3B,KAC8C,UAD9C;AAC8C,IAC1C,WADJ,GACkB,OAAO,oBADzB,KACkD,UADlD;AACkD,IAC9C,cADJ,GACqB,KADrB;AACqB,GAArB,GACM,OADN,CAAA;AAEE,EAAF,MAAQ,WAAR,GAAsB,aAAtB,CAAoC,SAAS,CAA7C,CAAA;AACE,EAAF,MAAQ,SAAR,GAAoB,cAApB,IAAsC,cAAtC,GAAuD,CAAC,GAAI,WAA5D,GAA0E,oBAA1E,CAA+F,WAAW,CAA1G,GAA8G,EAA9G,EAAmH,GAAG,oBAAtH,CAA2I,QAAQ,CAAC,CAApJ,GAAwJ,EAAxJ,CAAA;AACE,EAAF,SAAA,CAAY,OAAZ,CAAoB,CAApB,QAAA,KAAgC;AAC5B,IAAJ,cAAA,IAAsB,QAAtB,CAA+B,gBAA/B,CAAgD,QAAhD,EAA0D,MAA1D,EAAkE;AAAA,MAC5D,OADN,EACe,IADf;AACe,KACV,CADL,CAAA;AAEI,IAAJ,cAAA,IAAsB,QAAtB,CAA+B,gBAA/B,CAAgD,QAAhD,EAA0D,MAAM,CAAhE,CAAA;AAAgE,GAC7D,CADH,CAAA;AAEE,EAAF,MAAQ,SAAR,GAAoB,WAApB,IAAmC,WAAnC,GAAiD,WAAjD,CAA6D,WAA7D,EAA0E,MAAM,CAAhF,GAAoF,IAApF,CAAA;AACE,EAAF,IAAM,cAAN,GAAuB,CAAvB,CAAA,CAAA;AACE,EAAF,IAAM,cAAN,GAAuB,IAAvB,CAAA;AACE,EAAF,IAAM,aAAN,EAAqB;AACjB,IAAJ,cAAA,GAAqB,IAAI,cAAzB,CAAwC,CAAxC,IAAA,KAAgD;AAC1C,MAAN,IAAU,CAAC,UAAU,CAArB,GAAyB,IAAzB,CAAA;AACM,MAAN,IAAU,UAAV,IAAwB,UAAxB,CAAmC,MAAnC,KAA8C,WAA9C,IAA6D,cAA7D,EAA6E;AAGrE,QAAR,cAAA,CAAuB,SAAvB,CAAiC,QAAQ,CAAzC,CAAA;AACQ,QAAR,oBAAA,CAA6B,cAAc,CAA3C,CAAA;AACQ,QAAR,cAAA,GAAyB,qBAAzB,CAA+C,MAAM;AAC3C,UAAV,cAAA,IAA4B,cAA5B,CAA2C,OAA3C,CAAmD,QAAQ,CAA3D,CAAA;AAA2D,SAClD,CADT,CAAA;AACS,OAAT;AAEM,MAAN,MAAA,EAAA,CAAA;AACA,KAAK,CAAL,CAAA;AACI,IAAJ,IAAQ,WAAR,IAAuB,CAAC,cAAxB,EAAwC;AAClC,MAAN,cAAA,CAAqB,OAArB,CAA6B,WAAW,CAAxC,CAAA;AAAwC,KAAxC;AAEI,IAAJ,cAAA,CAAmB,OAAnB,CAA2B,QAAQ,CAAnC,CAAA;AAAmC,GAAnC;AAEE,EAAF,IAAM,OAAN,CAAA;AACE,EAAF,IAAM,WAAN,GAAoB,cAApB,GAAqC,qBAArC,CAA2D,SAAS,CAApE,GAAwE,IAAxE,CAAA;AACE,EAAF,IAAM,cAAN,EAAsB;AAClB,IAAJ,SAAA,EAAA,CAAA;AACA,GAAA;AACE,EAAF,SAAW,SAAX,GAAuB;AACnB,IAAJ,MAAU,WAAV,GAAwB,qBAAxB,CAA8C,SAAS,CAAvD,CAAA;AACI,IAAJ,IAAQ,WAAR,KAAwB,WAAxB,CAAoC,CAApC,KAA0C,WAA1C,CAAsD,CAAtD,IAA2D,WAA3D,CAAuE,CAAvE,KAA6E,WAA7E,CAAyF,CAAzF,IAA8F,WAA9F,CAA0G,KAA1G,KAAoH,WAApH,CAAgI,KAAhI,IAAyI,WAAzI,CAAqJ,MAArJ,KAAgK,WAAhK,CAA4K,MAA5K,CAAA,EAAqL;AAC/K,MAAN,MAAA,EAAA,CAAA;AACA,KAAA;AACI,IAAJ,WAAA,GAAkB,WAAlB,CAAA;AACI,IAAJ,OAAA,GAAc,qBAAd,CAAoC,SAAS,CAA7C,CAAA;AAA6C,GAA7C;AAEE,EAAF,MAAA,EAAA,CAAA;AACE,EAAF,OAAS,MAAM;AACX,IAAJ,SAAA,CAAc,OAAd,CAAsB,CAAtB,QAAA,KAAkC;AAC5B,MAAN,cAAA,IAAwB,QAAxB,CAAiC,mBAAjC,CAAqD,QAArD,EAA+D,MAAM,CAArE,CAAA;AACM,MAAN,cAAA,IAAwB,QAAxB,CAAiC,mBAAjC,CAAqD,QAArD,EAA+D,MAAM,CAArE,CAAA;AAAqE,KAChE,CADL,CAAA;AAEI,IAAJ,SAAA,IAAiB,SAAjB,EAAA,CAAA;AACI,IAAJ,cAAA,IAAsB,cAAtB,CAAqC,UAArC,EAAA,CAAA;AACI,IAAJ,cAAA,GAAqB,IAArB,CAAA;AACI,IAAJ,IAAQ,cAAR,EAAwB;AAClB,MAAN,oBAAA,CAA2B,OAAO,CAAlC,CAAA;AAAkC,KAAlC;AACK,GAAL,CAAA;AAEA,CAAA;AAeA,MAAM,KAAN,GAAc,OAAd,CAAA;AAQA,MAAM,IAAN,GAAa,MAAb,CAAA;AAwCA,MAAM,eAAN,GAAwB,CAAC,SAAzB,EAAoC,QAApC,EAA8C,OAA9C,KAA0D;AAIxD,EAAF,MAAQ,KAAR,mBAAA,IAAoB,GAApB,EAAA,CAAA;AACE,EAAF,MAAQ,aAAR,GAAwB;AAAA,IACpB,QADJ;AACI,IACA,GAAG,OADP;AACO,GAAP,CAAA;AAEE,EAAF,MAAQ,iBAAR,GAA4B;AAAA,IACxB,GAAG,aADP,CACqB,QADrB;AACqB,IACjB,EADJ,EACQ,KADR;AACQ,GAAR,CAAA;AAEE,EAAF,OAAS,iBAAT,CAA2B,SAA3B,EAAsC,QAAtC,EAAgD;AAAA,IAC5C,GAAG,aADP;AACO,IACH,QADJ,EACc,iBADd;AACc,GACX,CADH,CAAA;AAEA,CAAA,CAAA;;;;;;;;;;;;;;;;ADhpBW,EAAX,IAAW,EAAA,aAAX,GAA2B,KAA3B,EAAA,GAAgC,OAAhC,CAAA;AACW,EAAX,IAAW,EAAA,KAAX,GAAmB,IAAnB,EAAA,GAAuB,OAAvB,CAAA;AACW,EAAX,IAAW,EAAX,MAAA,EAAWT,QAAX,GAAoB,CAApB,EAAA,GAAqB,OAArB,CAAA;AACW,EAAX,IAAW,EAAA,SAAX,GAAuB,KAAvB,EAAA,GAA4B,OAA5B,CAAA;AACW,EAAX,IAAW,EAAA,OAAX,GAAqB,OAArB,EAAA,GAA4B,OAA5B,CAAA;AACW,EAAX,IAAW,EAAA,WAAX,GAAyB,KAAzB,CAAA,EAAA,GAAkC,OAAlC,CAAA;AACW,EAAX,IAAW,EAAA,SAAX,GAAuB,KAAvB,CAAA,EAAA,GAAgC,OAAhC,CAAA;AACW,EAAX,IAAW,EAAA,QAAX,GAAsB,UAAtB,EAAA,GAAgC,OAAhC,CAAA;AACW,EAAX,IAAW,EAAA,IAAX,GAAkB,KAAlB,EAAA,GAAuB,OAAvB,CAAA;AACW,EAAX,IAAW,EAAA,KAAX,GAAmB,KAAnB,EAAA,GAAwB,OAAxB,CAAA;AAEW,EAAX,IAAW,EAAA,WAAX,GAAA,CAA0BO,IAA1B,EAAA,EAAsCC,KAAtC,EAA+C,CAA/C,EAAA,GAA+C,OAA/C,CAAA;AACM,EAAN,MAAM,QAAN,GAAiB,qBAAjB,EAAA,CAAA;AAKA,EAAA,IAAI,WAAJ,CAAA;AACA,EAAA,IAAI,UAAJ,CAAA;AACA,EAAA,IAAI,OAAJ,CAAA;AACA,EAAA,IAAI,SAAJ,CAAA;AAiBA,EAAA,MAAM,EAAN,GAAY,CAAZ,CAAA,KAAmB,CAAnB,IAAwB,IAAxB,GAA4B,CAA5B,EAAkC,CAAC,CAAnC,EAAA,CAAA,GAA0C,EAA1C,CAAA;AAeA,EAAA,IAAI,SAAJ,CAAA;AACAL,EAAAA,MAAMA,gBAANA,GAAqB;AAAA,IACjB,IADJ,EACU,OADV;AACU,IACN,KADJ,EACW,MADX;AACW,IACP,MADJ,EACY,KADZ;AACY,IACR,GADJ,EACS,QADT;AACS,GAAT,CAAA;AAGA,EAAA,SAAS,cAAT,GAAuB;AACnBG,IAAJA,eAAAA,CAAwB,WAAxBA,EAAqC,UAArCA,EAA+C,EAAI,SAAnDA,EAA8D,QAA9DA,EAAwE,UAAxEA,EAAsF,CAAtFA,CAAsF,IAAtFA,CAA8F,CAAA,EAAA,CAA9FA,EAAiG,CAAjGA,EAAoG,cAApGA,EAAoH,SAApHA,EAAoHF,UAApHE,EAA+H,QAA/HA,EAA+HD,SAA/HC,EAAAA,KAAuI;AAC/H,MAAR,UAAA,CAAmB,KAAnB,CAAyB,QAAzB,GAAoCD,SAApC,CAAA;AACQ,MAAR,UAAA,CAAmB,KAAnB,CAAyB,IAAzB,GAAgC,KAAhC,GAAwC,GAAxC,GAA8C,EAA9C,CAAiD,CAAC,CAAlD,CAAA;AACQ,MAAR,UAAA,CAAmB,KAAnB,CAAyB,GAAzB,GAA+B,EAA/B,CAAkC,CAAC,CAAnC,CAAA;AACY,MAAZ,IAAY,cAAZ,CAA2B,KAA3B,IAAoC,OAApC,YAAuD,cAAvD,EAAqE;AACzD,QAAZ,OAAA,CAAoB,KAApB,CAA0B,IAA1B,GAAiC,EAAjC,CAAoC,cAApC,CAAmD,KAAnD,CAAyD,CAAC,CAA1D,CAAA;AACY,QAAZ,OAAA,CAAoB,KAApB,CAA0B,GAA1B,GAAgC,EAAhC,CAAmC,cAAnC,CAAkD,KAAlD,CAAwD,CAAC,CAAzD,CAAA;AACY,QAAZ,SAAA,GAAwBF,gBAAxB,CAAwCC,UAAxC,CAAkD,KAAlD,CAAwD,GAAG,CAA3D,CAA6D,CAAC,CAAA,CAA9D,CAAA;AACY,QAAZ,OAAA,CAAoB,KAApB,CAA0B,SAAS,CAAnC,GAAuC,EAAvC,CAAA,CAA2C,OAA3C,CAAmD,WAAnD,GAAiE,CAAjE,IAAsE,OAAtE,CAA8E,MAA9E,GAAuF,CAAvF,GAA2F,CAA3F,CAA4F,CAA5F,CAAA;AAA4F,OAA5F;;;AAIA,EAAA,SAAS,IAAT,CAAc,IAAd,EAAoB,YAApB,EAAgC;AAC5B,IAAJ,UAAA,GAAiB,IAAjB,CAAA;AACA,IAAA,IAAQ,OAAR,GAAkBH,UAAlB,CAAiC,YAAjC,EAA+C,UAA/C,EAA2D,cAAc,CAAzE,CAAA;;AAEA,MAAQ,MAAR,CAAeC,aAAf,EAA2B;AACf,QAAZ,OAAA,EAAA,CAAA;AACY,QAAZ,OAAA,GAAsBD,UAAtB,CAAqCC,aAArC,EAAmD,UAAnD,EAA+D,cAAc,CAA7E,CAAA;AAA6E,OAA7E;AAEA,MAAQ,OAAR,GAAe;AACH,QAAZ,OAAA,EAAA,CAAA;;;;AAyDA,EAAA,IAAI,UAAJ,CAAA;;;;;;;;;;;;;;;;;;;;;;;;AA5HG,IAAH,QAAA,CAAY,MAAZ,EAAoB,IAAI,CAAxB,CAAA;AAAwB,GAAxB;AACG,EAAH,SAAA,KAAiB,WAAjB,GAA+B,WAA/B,CAAA,CAAA;AA2CG,EAAH,UAAA,GAAa;AAAA,IAAb,GAAoB,WAApB;AAAoB,IAAaH,MAAjC,CAA2C,CAAEC,QAAM,CAAnD;AAAmD,IAAG,OAAtD;AAAsD,GAAtD,CAAA;AAiFG,EAAH,UAAA,GAAgB,MAAhB,CAAuB,0FAAvB,EAAmH,OAAnH,CAA2H,MAA3H,IAAqI,SAArI,KAAmJ,QAAnJ,IAA+J,mBAA/J,EAAoL,OAApL,CAA4L,MAA5L,IAAsM,SAAtM,KAAoN,KAApN,IAA6N,oBAA7N,EAAmP,OAAnP,CAA2P,MAA3P,IAAqQ,SAArQ,KAAmR,OAAnR,IAA8R,oBAA9R,EAAoT,OAApT,CAA4T,MAA5T,IAAsU,SAAtU,KAAoV,MAApV,IAA8V,oBAAoB,CAAlX,CAAA;AAWA,EAAA,OAAA,CAAA,EAAA,CAAM,WAAN,GAAA,CAAA,IAAA,EAAA,aAAA,CAAA,MAAA,EACkB,SADlB,EAC2B,CAAA,CAAA,CAD3B,OAAA,CAAA,GAIK,CAJL,CAIK,CAJL,CAAA,EAIK,IAJL,IAIa,WAJb,GAAA,CAAA,EAAA,kBAAA,CAAA,KAAA,EAAA,OAAA,CAAA,CAAA,QAAA,CAAA,QAAA,EAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EAAA,EAAA,GAAA,EAKc,IALd,EAAA,EAKkB,EAAA,OALlB,EAK6B,WAL7B,EAAA,EAKmE,EAAA,IALnE,EAKmE,SALnE,EAAA,EAKmE,EAAA,QALnE,EAKmE,aALnE,GAAA,CAAA,CAAA,GAKwF,KALxF,CAAA,EAAA,EAKkV,WAAW,CAL7V,EAK6V,EAL7V,EAK6V;AAAA,IAA7V,OAAA,EAAA,MAAA;AAEA,MAAA,OAAA,CAAA,EAAA,KAAA,CAAA,OAAA,GAAA,KAAA,CAAA,OAAA,CAAA,EAAA,CAAA,GAAA,CAAA,CAAA,CAAA,CAAA,EAAS,KAAT,GAAA,CAAA,IAAA,EAAA,aAAA,CAAA,OAAA,EAAyC,UAAzC,EAAmD,CAAA,CAAA,CAAnD,OAAA,CAAA,GAAA,CAAA,CAAA,CAAA,CAAA,CAAA;;;;;;;AD3JA,EAAA,MAAM,cAAN,GAAuB,QAAvB,CAAgC,EAAE,CAAlC,CAAA;AACW,EAAX,IAAW,EAAA,SAAX,GAAuB,EAAvB,EAAA,GAAyB,OAAzB,CAAA;AACW,EAAX,IAAW,EAAA,IAAX,GAAkB,KAAlB,EAAA,GAAuB,OAAvB,CAAA;AACW,EAAX,IAAW,EAAA,cAAX,GAA4B,eAA5B,EAAA,GAA2C,OAA3C,CAAA;AACW,EAAX,IAAW,EAAA,WAAX,GAAyB,mCAAzB,EAAA,GAA4D,OAA5D,CAAA;AACW,EAAX,IAAW,EAAA,WAAX,GAAyB,mCAAzB,EAAA,GAA4D,OAA5D,CAAA;AACW,EAAX,IAAW,EAAA,WAAX,GAAyB,2FAAzB,EAAA,GAAoH,OAApH,CAAA;AACI,EAAJ,IAAI,SAAJ,GAAgB,OAAhB,CAAwB,WAAxB,EAAqC,OAArC,CAA6C,WAAW,CAAxD,CAAA;AACA,EAAA,UAAA,CAAW,cAAX,EAA6B,EAAA,WAA7B,EAA0C,SAA1C,EAAmD,CAAnD,CAAA;AAEA,EAAA,UAAA,CAAW,WAAX,EAAwB,cAAc,CAAtC,CAAA;AACI,EAAJ,IAAI,YAAJ,GAAmB,OAAnB,CAA2B,cAA3B,EAA2C,OAA3C,CAAmD,cAAc,CAAjE,CAAA;AACI,EAAJ,IAAI,SAAJ,GAAgB,OAAhB,CAAwB,WAAxB,EAAqC,OAArC,CAA6C,WAAW,CAAxD,CAAA;AACI,EAAJ,IAAI,KAAJ,GAAY,OAAZ,CAAoB,MAApB,EAA4B,OAA5B,CAAoC,KAAK,CAAzC,CAAA;AACI,EAAJ,IAAI,SAAJ,GAAgB,OAAhB,CAAwB,WAAxB,EAAqC,OAArC,CAA6C,WAAW,CAAxD,CAAA;;;;;;;;;;;;;;;;;;;;AALG,MAAH,cAAA,CAAkB,GAAlB,CAAsB,SAAS,CAA/B,CAAA;AAA+B,KAA/B;;;AAQI,QAAJ,WAAA,CAAgB,KAAhB,GAAwB,WAAxB,CAAoC,KAApC,IAA6C,KAA7C,CAAA;AACI,QAAJ,WAAA,CAAgB,OAAhB,GAA0B,WAA1B,CAAsC,OAAtC,IAAiD,OAAjD,CAAA;AACI,QAAJ,WAAA,CAAgB,SAAhB,GAA4B,WAA5B,CAAwC,SAAxC,IAAqD,QAArD,CAAA;AACI,QAAJ,WAAA,CAAgB,KAAhB,GAAwB,WAAxB,CAAoC,KAApC,IAA6C,UAA7C,CAAA;AACI,QAAJ,WAAA,CAAgB,MAAhB,GAAyB,WAAzB,CAAqC,MAArC,IAA+C,IAA/C,CAAA;AACI,QAAJ,WAAA,CAAgB,OAAhB,GAA0B,WAA1B,CAAsC,OAAtC,IAAiD,IAAjD,CAAA;AAAiD,OAAjD;;;;AAIA,MAA0B,MAA1B,CAA0B,MAA1B,CAA0B,EAA1B,EAA0B,EAAA,aAA1B,EAA0B,IAA1B,EAAA,EAA0B,WAA1B,EAAA,EAAA,KAAA,EAA8C,YAA9C,EAAA,EAA0D,EAAA,IAA1D,EAA0D,CAA1D;AAA0D,MAA1D;;;;;;;;AACO,UAAP,OAAO,CAAP,EAAO,OAAP,CAAe,MAAf,GAAA,CAAA,IAAA,EAAA,aAAA,CAAA,OAAA,EACgB,SADhB,EACyB,CAAA,CAAA,CADzB,CAAA,EACyB,KADzB,CACyB,MADzB,GACyB,KADzB,CACyB,MADzB,CACyB,EAAA,CADzB,GACyB,CADzB,CACyB,CADzB,MAAA,CAAA,GAAA,CAAA,CAAA,CAAA,IAAA,EAAA,aAAA,CAAA,OAAA,EAKa,KALb,EAKkB,CAAA,CAAA,CALlB,CAAA,EAKkB,KALlB,CAKkB,OALlB,GAKkB,KALlB,CAKkB,OALlB,CAKkB,EAAA,CALlB,GAKkB,CALlB,CAKkB,CALlB,MAAA,EAQO,OARP,CAQe,MARf,GAAA,CAAA,IAAA,EAAA,aAAA,CAAA,OAAA,EASgB,SAThB,EASyB,CAAA,CAAA,CATzB,CAAA,EASyB,KATzB,CASyB,MATzB,GASyB,KATzB,CASyB,MATzB,CASyB,EAAA,CATzB,GASyB,CATzB,CASyB,CATzB,MAAA,CAAA,GAAA,CAAA,CAAA,CAAA,CAAA,CAAA;;;;;;;;;;;AD/BW,EAAX,IAAW,EAAA,YAAX,GAA0B,wEAA1B,EAAA,GAAkG,OAAlG,CAAA;AACW,EAAX,IAAW,EAAA,IAAX,GAAkB,KAAlB,CAAA,EAAA,GAA2B,OAA3B,CAAA;AACW,EAAX,IAAW,EAAA,WAAX,GAAyB,KAAzB,CAAA,EAAA,GAAkC,OAAlC,CAAA;AAEA,EAAA,MAAM,OAAN,GAAgB,UAAhB,CAA2B,cAAc,CAAzC,IAAyC,EAAzC,CAAA;AACA,EAAA,MAAM,cAAN,GAAuB,UAAvB,CAAkC,WAAW,CAA7C,CAAA;AACI,EAAJ,IAAI,UAAJ,GAAiB,EAAjB,CAAA;AACA,EAAA,cAAA,CAAe,SAAf,CAA0B,CAA1B,KAAA,KAA+B;AAE3B,IAAJ,UAAA,GAAiB,KAAjB,CAAA;AAAiB,GAAjB,CAAA,CAAA;AAOI,EAAJ,IAAI,IAAJ,GAAW,IAAX,CAAA;AACS,EAAT,SAAS,IAAT,CAAc,IAAd,EAAkB;AACd,IAAJ,IAAA,GAAW,IAAX,CAAgB,aAAhB,EAA+B,OAA/B,KAA2C,IAA3C,CAAA;AAA2C,GAA3C;;;;;;;AAPG,EAAH,MAAA,GAAY,UAAZ,GAAyB,IAAzB,KAAkC,UAAlC,GAA+C,KAA/C,CAAA;AAEG,EAAH,OAAA,GAAa,OAAb,CAAqB,YAArB,EAAmC,IAAnC,GAA0C,OAA1C,GAAoD,kBAApD,EAAwE,MAAxE,KAAmF,WAAnF,IAAkG,OAAlG,CAA0G,WAA1G,CAAA,EAAwH,OAAxH,CAAgI,KAAK,CAArI,CAAA;AASwB,EAAxB,OAAwB,CAAxB,EAAwB,kBAAxB,CAAwB,OAAxB,EAAwB,SAAA,CAAxB,CAAwB,QAAxB,CAAwB,QAAxB,EAAwB,EAAA,GAAxB,EAAwB,IAAxB,EAAwB,IAAxB,EAAwB,IAAxB,EAAA,GAAA,EAAmC,IAAnC,EAAA,EAAuC,EAAvC,EAAuC;AAAA,IAAvC,OAAA,EAAA,MAAA;;AACA,QAAA,OAAA,GAAA,GAAA,CAAA,CAAA,EAAwB,IAAxB,GAA+B,GAA/B,GAAqC,QAAQ,CAA7C,EAA6C,MAA7C;AAA6C,UAA7C;;;AAAA,cAAA,IAAA,EAAA,sBAAA,CAA4D,IAA5D,GAAmE,KAAnE,CAAA,GAA+E,QAAQ,CAAvF;AAAuF,aAAvF;;AAAA,cAAA,IAAA,EAAA,sBAAA,CAA+F,IAA/F,GAAsG,MAAtG,GAA+G,QAAQ,CAAvH;AAAuH,aAAvH;AAAA,YAAA,aAAA,CAA6H,WAAW,CAAxI;AAAwI,YAAxI,EAAA,KAAA,EAAA,sBAAA,CAAiJ,OAAO,CAAxJ,EAAA;AAAwJ,WAAxJ;;;AAAA,OAAA,EAAwB,IAAxB,GAA+B,GAA/B,GAAqC,QAAQ,CAAA,CAA7C,CAAA,CAAA;AAA6C,KAA7C;;;;;ADxBA,EAAA,MAAM,GAAN,GAAY,UAAZ,CAAuB,SAAS,CAAhC,IAAgC,EAAhC,CAAA;AACA,EAAA,MAAM,KAAN,GAAW;AAAA,IACP,EADJ,EACQ,SADR;AACQ,IACJ,EADJ,EACQ,SADR;AACQ,IACJ,EADJ,EACQ,SADR;AACQ,IACJ,EADJ,EACQ,SADR;AACQ,IACJ,EADJ,EACQ,SADR;AACQ,GAAR,CAAA;AAEW,EAAX,IAAW,EAAA,IAAX,GAAkB,GAAlB,CAAsB,IAAtB,IAA8B,IAA9B,EAAA,GAAkC,OAAlC,CAAA;AACW,EAAX,IAAW,EAAA,IAAX,GAAkB,GAAlB,CAAsB,IAAtB,IAA8B,KAA9B,EAAA,GAAmC,OAAnC,CAAA;AACW,EAAX,IAAW,EAAA,SAAX,GAAuB,oBAAvB,EAAA,GAA2C,OAA3C,CAAA;;;;;;;;;;;AAMA,MAAA,aAAA,CAAM,WAAW,CAAjB;AAAiB,MAAjB;AACA,QAAA,KAAA,EAAA,sBAAA,CAAS,OAAT,CAAiB,UAAjB,EAA6B,KAA7B,CAAmC,IAAI,CAAvC,EAA0C,OAA1C,CAAkD,KAAK,CAAA,CAAvD;AAAuD,OAAvD;;;AAEA,QAAA,YAAA,EAAA,sBAAA,CAAc,SAAS,CAAvB;AAAuB,OAAvB;;;;;;;;;"}