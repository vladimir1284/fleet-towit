// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

generator zod {
  provider = "zod-prisma-types"
  output   = "../src/lib/zod"
}

generator dbml {
  provider = "prisma-dbml-generator"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
  id            String        @id @default(cuid()) /// @zod.custom.omit([model,Â input])
  name          String?
  email         String?       @unique
  emailVerified DateTime?
  image         String?
  accounts      Account[]
  sessions      Session[]
  tenantUsers   TenantUser[]

  createdParts Part[] @relation("creationAuthor")
  updatedParts Part[] @relation("updateAuthor")
  deletedParts Part[] @relation("deletionAuthor")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model TenantUser {
  id        String  @id @default(cuid())
  role      Role    @default(STAFF)
  tenantId  String
  tenant    Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  userId    String
  user      User    @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Client {
  id          String  @id @default(cuid())
  name        String
  email       String
  phoneNumber String  @unique /// @zod.string.regex(new RegExp(/^([+]?[\s0-9]+)?(\d{3}|[(]?[0-9]+[)])?([-]?[\s]?[0-9])+$/), { message:"Invalid Number!"})
  avatar      String?
  tenantId    String
  tenant      Tenant @relation(fields: [tenantId], references: [id])

}

model Tenant {
  id          String       @id @default(cuid())
  name        String
  email       String?
  isAdmin     Boolean      @default(false)
  clients     Client[]
  tenantUsers TenantUser[] 
}

enum Role {
  STAFF
  ADMIN
  OWNER
}

// Inventory-related models.

model Part {
  id               String @id @default(cuid())
  name             String
  number           Int
  criticalQty      Int
  upc              Int
  description      String @db.Text
  extendedPartData Json?

  // Built-in.
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime? // nullable field to simulate deletedAt built-in method.

  categories CategoriesOnParts[]
  locations  LocationsOnParts[]
  vendors    VendorOnParts[]

  createdBy String
  updatedBy String
  deletedBy String

  // Relations.
  creationAuthor User @relation("creationAuthor", fields: [createdBy], references: [id], onDelete: Cascade, onUpdate: Cascade)
  updateAuthor   User @relation("updateAuthor", fields: [updatedBy], references: [id], onDelete: Cascade, onUpdate: Cascade)
  deletionAuthor User @relation("deletionAuthor", fields: [deletedBy], references: [id], onDelete: Cascade, onUpdate: Cascade)
}

model Category {
  id   Int    @id @default(autoincrement())
  name String @unique

  // Built-in.
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime? // nullable field to simulate deletedAt built-in method.

  parts CategoriesOnParts[]
}

model Location {
  id   Int    @id @default(autoincrement())
  name String @unique

  // Built-in.
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime? // nullable field to simulate deletedAt built-in method.

  parts LocationsOnParts[]
}

model Vendor {
  id   Int    @id @default(autoincrement())
  name String @unique

  // Built-in.
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime? // nullable field to simulate deletedAt built-in method.

  parts VendorOnParts[]
}

model CategoriesOnParts {
  part       Part     @relation(fields: [partId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  partId     String   @unique
  category   Category @relation(fields: [categoryId], references: [id])
  categoryId Int

  @@id([partId, categoryId])
}

model LocationsOnParts {
  part       Part     @relation(fields: [partId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  partId     String   @unique
  Location   Location @relation(fields: [locationId], references: [id])
  locationId Int

  // Location-per-part fields.
  quantity Int
  unit     String

  @@id([partId, locationId])
}

model VendorOnParts {
  part     Part   @relation(fields: [partId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  partId   String @unique
  vendor   Vendor @relation(fields: [vendorId], references: [id])
  vendorId Int

  // Vendor-per-part price.
  cost Float

  @@id([partId, vendorId])
}
