// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

generator zod {
  provider = "zod-prisma-types"
  output   = "../src/lib/zod"
}

generator dbml {
  provider = "prisma-dbml-generator"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
  id            String    @id @default(cuid()) /// @zod.custom.omit([model,Â input])
  name          String?
  email         String?   @unique
  emailVerified DateTime?
  image         String?
  accounts      Account[]
  sessions      Session[]

  tenantUsers TenantUser[]
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model TenantUser {

  id       String @id @default(cuid()) @db.VarChar(30)
  role     Role   @default(STAFF)
  tenantId String
  tenant   Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  userId   String
  user     User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdParts Part[] @relation("creationAuthor")
  updatedParts Part[] @relation("updateAuthor")
  deletedParts Part[] @relation("deletionAuthor")
  customFieldResponses CustomFieldResponse[]
}

model Client {
  id          String  @id @default(cuid())
  name        String
  email       String
  phoneNumber String  @unique /// @zod.string.regex(new RegExp(/^([+]?[\s0-9]+)?(\d{3}|[(]?[0-9]+[)])?([-]?[\s]?[0-9])+$/), { message:"Invalid Number!"})
  avatar      String?

  tenantId String
  tenant   Tenant @relation(fields: [tenantId], references: [id])
}

model Tenant {
  id          String       @id @default(cuid()) @db.VarChar(30)
  name        String
  email       String?
  isAdmin     Boolean      @default(false)
  clients     Client[]
  tenantUsers TenantUser[]
  customForms          CustomForm[]
  Part        Part[]
  Category    Category[]
  Location    Location[]
  Vendor      Vendor[]
}

enum Role {
  STAFF
  ADMIN
  OWNER
}

model CustomForm {
  id           Int           @id @default(autoincrement())
  name         String
  tenantId String
  user         Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  createdAt    DateTime      @default(now())
  fields       CustomField[]
}

enum FormFieldType {
  TEXT
  NUMBER
  RADIO
  CHECKBOX
}

model CustomField {
  id        Int                   @id @default(autoincrement())
  name      String
  type      FormFieldType
  required  Boolean?              @default(true)
  formId    Int
  form      CustomForm            @relation(fields: [formId], references: [id], onDelete: Cascade)
  responses CustomFieldResponse[]
}

model CustomFieldResponse {
  id           Int         @id @default(autoincrement())
  content      String
  tenantUserId String
  user         TenantUser  @relation(fields: [tenantUserId], references: [id], onDelete: Cascade)
  fieldId      Int
  field        CustomField @relation(fields: [fieldId], references: [id], onDelete: Cascade)
  createdAt    DateTime    @default(now())

}

// Inventory-related models.

model Part {
  id               String @id @default(cuid()) @db.VarChar(30)
  name             String
  number           Int
  criticalQty      Int
  upc              Int
  description      String @db.Text
  extendedPartData Json?

  // Amazon S3 services.
  image String? @db.Text

  // Built-in.
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime? // nullable field to simulate deletedAt built-in method.

  categories CategoriesOnParts[]
  locations  LocationsOnParts[]
  vendors    VendorOnParts[]

  createdBy String? @db.VarChar(30)
  updatedBy String? @db.VarChar(30)
  deletedBy String? @db.VarChar(30)

  // Relations.
  creationAuthor TenantUser? @relation("creationAuthor", fields: [createdBy], references: [id], onDelete: Cascade, onUpdate: Cascade)
  updateAuthor   TenantUser? @relation("updateAuthor", fields: [updatedBy], references: [id], onDelete: Cascade, onUpdate: Cascade)
  deletionAuthor TenantUser? @relation("deletionAuthor", fields: [deletedBy], references: [id], onDelete: Cascade, onUpdate: Cascade)

  // Multi-tenant identification.
  tenantId String @db.VarChar(30)
  tenant   Tenant @relation(fields: [tenantId], references: [id])
}

model Category {
  id   String @id @default(cuid()) @db.VarChar(30)
  name String @unique

  // Built-in.
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime? // nullable field to simulate deletedAt built-in method.

  parts CategoriesOnParts[]

  // Multi-tenant identification.
  tenant   Tenant @relation(fields: [tenantId], references: [id])
  tenantId String
}

model Location {
  id   String @id @default(cuid()) @db.VarChar(30)
  name String @unique

  // Built-in.
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime? // nullable field to simulate deletedAt built-in method.

  parts LocationsOnParts[]

  // Multi-tenant identification.
  tenantId String @db.VarChar(30)
  tenant   Tenant @relation(fields: [tenantId], references: [id])
}

model Vendor {
  id   String @id @default(cuid()) @db.VarChar(30)
  name String @unique

  // Built-in.
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime? // nullable field to simulate deletedAt built-in method.

  parts VendorOnParts[]

  // Multi-tenant identification.
  tenantId String @db.VarChar(30)
  tenant   Tenant @relation(fields: [tenantId], references: [id])
}

model CategoriesOnParts {
  part       Part     @relation(fields: [partId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  partId     String   @db.VarChar(30)
  category   Category @relation(fields: [categoryId], references: [id])
  categoryId String   @db.VarChar(30)

  @@id([partId, categoryId])
}

model LocationsOnParts {
  part       Part     @relation(fields: [partId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  partId     String   @db.VarChar(30)
  Location   Location @relation(fields: [locationId], references: [id])
  locationId String   @db.VarChar(30)

  // Location-per-part fields.
  quantity Int
  unit     String

  @@id([partId, locationId])
}

model VendorOnParts {
  part     Part   @relation(fields: [partId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  partId   String @db.VarChar(30)
  vendor   Vendor @relation(fields: [vendorId], references: [id])
  vendorId String @db.VarChar(30)

  // Vendor-per-part price.
  cost Float

  @@id([partId, vendorId])
}
